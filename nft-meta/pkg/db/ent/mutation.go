// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/google/uuid"
	"github.com/web3eye-io/Web3Eye/nft-meta/pkg/db/ent/block"
	"github.com/web3eye-io/Web3Eye/nft-meta/pkg/db/ent/contract"
	"github.com/web3eye-io/Web3Eye/nft-meta/pkg/db/ent/endpoint"
	"github.com/web3eye-io/Web3Eye/nft-meta/pkg/db/ent/orderitem"
	"github.com/web3eye-io/Web3Eye/nft-meta/pkg/db/ent/orderpair"
	"github.com/web3eye-io/Web3Eye/nft-meta/pkg/db/ent/predicate"
	"github.com/web3eye-io/Web3Eye/nft-meta/pkg/db/ent/snapshot"
	"github.com/web3eye-io/Web3Eye/nft-meta/pkg/db/ent/synctask"
	"github.com/web3eye-io/Web3Eye/nft-meta/pkg/db/ent/token"
	"github.com/web3eye-io/Web3Eye/nft-meta/pkg/db/ent/transfer"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlock     = "Block"
	TypeContract  = "Contract"
	TypeEndpoint  = "Endpoint"
	TypeOrderItem = "OrderItem"
	TypeOrderPair = "OrderPair"
	TypeSnapshot  = "Snapshot"
	TypeSyncTask  = "SyncTask"
	TypeToken     = "Token"
	TypeTransfer  = "Transfer"
)

// BlockMutation represents an operation that mutates the Block nodes in the graph.
type BlockMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	chain_type      *string
	chain_id        *string
	block_number    *uint64
	addblock_number *int64
	block_hash      *string
	block_time      *int64
	addblock_time   *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Block, error)
	predicates      []predicate.Block
}

var _ ent.Mutation = (*BlockMutation)(nil)

// blockOption allows management of the mutation configuration using functional options.
type blockOption func(*BlockMutation)

// newBlockMutation creates new mutation for the Block entity.
func newBlockMutation(c config, op Op, opts ...blockOption) *BlockMutation {
	m := &BlockMutation{
		config:        c,
		op:            op,
		typ:           TypeBlock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockID sets the ID field of the mutation.
func withBlockID(id uuid.UUID) blockOption {
	return func(m *BlockMutation) {
		var (
			err   error
			once  sync.Once
			value *Block
		)
		m.oldValue = func(ctx context.Context) (*Block, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Block.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlock sets the old Block of the mutation.
func withBlock(node *Block) blockOption {
	return func(m *BlockMutation) {
		m.oldValue = func(context.Context) (*Block, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Block entities.
func (m *BlockMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Block.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *BlockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BlockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *BlockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BlockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *BlockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BlockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetChainType sets the "chain_type" field.
func (m *BlockMutation) SetChainType(s string) {
	m.chain_type = &s
}

// ChainType returns the value of the "chain_type" field in the mutation.
func (m *BlockMutation) ChainType() (r string, exists bool) {
	v := m.chain_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChainType returns the old "chain_type" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldChainType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainType: %w", err)
	}
	return oldValue.ChainType, nil
}

// ResetChainType resets all changes to the "chain_type" field.
func (m *BlockMutation) ResetChainType() {
	m.chain_type = nil
}

// SetChainID sets the "chain_id" field.
func (m *BlockMutation) SetChainID(s string) {
	m.chain_id = &s
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *BlockMutation) ChainID() (r string, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldChainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *BlockMutation) ResetChainID() {
	m.chain_id = nil
}

// SetBlockNumber sets the "block_number" field.
func (m *BlockMutation) SetBlockNumber(u uint64) {
	m.block_number = &u
	m.addblock_number = nil
}

// BlockNumber returns the value of the "block_number" field in the mutation.
func (m *BlockMutation) BlockNumber() (r uint64, exists bool) {
	v := m.block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "block_number" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldBlockNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds u to the "block_number" field.
func (m *BlockMutation) AddBlockNumber(u int64) {
	if m.addblock_number != nil {
		*m.addblock_number += u
	} else {
		m.addblock_number = &u
	}
}

// AddedBlockNumber returns the value that was added to the "block_number" field in this mutation.
func (m *BlockMutation) AddedBlockNumber() (r int64, exists bool) {
	v := m.addblock_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "block_number" field.
func (m *BlockMutation) ResetBlockNumber() {
	m.block_number = nil
	m.addblock_number = nil
}

// SetBlockHash sets the "block_hash" field.
func (m *BlockMutation) SetBlockHash(s string) {
	m.block_hash = &s
}

// BlockHash returns the value of the "block_hash" field in the mutation.
func (m *BlockMutation) BlockHash() (r string, exists bool) {
	v := m.block_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockHash returns the old "block_hash" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldBlockHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockHash: %w", err)
	}
	return oldValue.BlockHash, nil
}

// ResetBlockHash resets all changes to the "block_hash" field.
func (m *BlockMutation) ResetBlockHash() {
	m.block_hash = nil
}

// SetBlockTime sets the "block_time" field.
func (m *BlockMutation) SetBlockTime(i int64) {
	m.block_time = &i
	m.addblock_time = nil
}

// BlockTime returns the value of the "block_time" field in the mutation.
func (m *BlockMutation) BlockTime() (r int64, exists bool) {
	v := m.block_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockTime returns the old "block_time" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldBlockTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockTime: %w", err)
	}
	return oldValue.BlockTime, nil
}

// AddBlockTime adds i to the "block_time" field.
func (m *BlockMutation) AddBlockTime(i int64) {
	if m.addblock_time != nil {
		*m.addblock_time += i
	} else {
		m.addblock_time = &i
	}
}

// AddedBlockTime returns the value that was added to the "block_time" field in this mutation.
func (m *BlockMutation) AddedBlockTime() (r int64, exists bool) {
	v := m.addblock_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockTime resets all changes to the "block_time" field.
func (m *BlockMutation) ResetBlockTime() {
	m.block_time = nil
	m.addblock_time = nil
}

// Where appends a list predicates to the BlockMutation builder.
func (m *BlockMutation) Where(ps ...predicate.Block) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BlockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Block).
func (m *BlockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, block.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, block.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, block.FieldDeletedAt)
	}
	if m.chain_type != nil {
		fields = append(fields, block.FieldChainType)
	}
	if m.chain_id != nil {
		fields = append(fields, block.FieldChainID)
	}
	if m.block_number != nil {
		fields = append(fields, block.FieldBlockNumber)
	}
	if m.block_hash != nil {
		fields = append(fields, block.FieldBlockHash)
	}
	if m.block_time != nil {
		fields = append(fields, block.FieldBlockTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case block.FieldCreatedAt:
		return m.CreatedAt()
	case block.FieldUpdatedAt:
		return m.UpdatedAt()
	case block.FieldDeletedAt:
		return m.DeletedAt()
	case block.FieldChainType:
		return m.ChainType()
	case block.FieldChainID:
		return m.ChainID()
	case block.FieldBlockNumber:
		return m.BlockNumber()
	case block.FieldBlockHash:
		return m.BlockHash()
	case block.FieldBlockTime:
		return m.BlockTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case block.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case block.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case block.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case block.FieldChainType:
		return m.OldChainType(ctx)
	case block.FieldChainID:
		return m.OldChainID(ctx)
	case block.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case block.FieldBlockHash:
		return m.OldBlockHash(ctx)
	case block.FieldBlockTime:
		return m.OldBlockTime(ctx)
	}
	return nil, fmt.Errorf("unknown Block field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case block.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case block.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case block.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case block.FieldChainType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainType(v)
		return nil
	case block.FieldChainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case block.FieldBlockNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case block.FieldBlockHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockHash(v)
		return nil
	case block.FieldBlockTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockTime(v)
		return nil
	}
	return fmt.Errorf("unknown Block field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, block.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, block.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, block.FieldDeletedAt)
	}
	if m.addblock_number != nil {
		fields = append(fields, block.FieldBlockNumber)
	}
	if m.addblock_time != nil {
		fields = append(fields, block.FieldBlockTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case block.FieldCreatedAt:
		return m.AddedCreatedAt()
	case block.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case block.FieldDeletedAt:
		return m.AddedDeletedAt()
	case block.FieldBlockNumber:
		return m.AddedBlockNumber()
	case block.FieldBlockTime:
		return m.AddedBlockTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case block.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case block.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case block.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case block.FieldBlockNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	case block.FieldBlockTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockTime(v)
		return nil
	}
	return fmt.Errorf("unknown Block numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Block nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockMutation) ResetField(name string) error {
	switch name {
	case block.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case block.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case block.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case block.FieldChainType:
		m.ResetChainType()
		return nil
	case block.FieldChainID:
		m.ResetChainID()
		return nil
	case block.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case block.FieldBlockHash:
		m.ResetBlockHash()
		return nil
	case block.FieldBlockTime:
		m.ResetBlockTime()
		return nil
	}
	return fmt.Errorf("unknown Block field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Block unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Block edge %s", name)
}

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	chain_type    *string
	chain_id      *string
	address       *string
	name          *string
	symbol        *string
	creator       *string
	block_num     *uint64
	addblock_num  *int64
	tx_hash       *string
	tx_time       *uint32
	addtx_time    *int32
	profile_url   *string
	base_url      *string
	banner_url    *string
	description   *string
	remark        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Contract, error)
	predicates    []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id uuid.UUID) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contract entities.
func (m *ContractMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContractMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContractMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ContractMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ContractMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContractMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContractMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContractMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ContractMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ContractMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ContractMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ContractMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ContractMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ContractMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ContractMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetChainType sets the "chain_type" field.
func (m *ContractMutation) SetChainType(s string) {
	m.chain_type = &s
}

// ChainType returns the value of the "chain_type" field in the mutation.
func (m *ContractMutation) ChainType() (r string, exists bool) {
	v := m.chain_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChainType returns the old "chain_type" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldChainType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainType: %w", err)
	}
	return oldValue.ChainType, nil
}

// ResetChainType resets all changes to the "chain_type" field.
func (m *ContractMutation) ResetChainType() {
	m.chain_type = nil
}

// SetChainID sets the "chain_id" field.
func (m *ContractMutation) SetChainID(s string) {
	m.chain_id = &s
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *ContractMutation) ChainID() (r string, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldChainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *ContractMutation) ResetChainID() {
	m.chain_id = nil
}

// SetAddress sets the "address" field.
func (m *ContractMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ContractMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *ContractMutation) ResetAddress() {
	m.address = nil
}

// SetName sets the "name" field.
func (m *ContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContractMutation) ResetName() {
	m.name = nil
}

// SetSymbol sets the "symbol" field.
func (m *ContractMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *ContractMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *ContractMutation) ResetSymbol() {
	m.symbol = nil
}

// SetCreator sets the "creator" field.
func (m *ContractMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ContractMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ContractMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[contract.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ContractMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[contract.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ContractMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, contract.FieldCreator)
}

// SetBlockNum sets the "block_num" field.
func (m *ContractMutation) SetBlockNum(u uint64) {
	m.block_num = &u
	m.addblock_num = nil
}

// BlockNum returns the value of the "block_num" field in the mutation.
func (m *ContractMutation) BlockNum() (r uint64, exists bool) {
	v := m.block_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNum returns the old "block_num" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldBlockNum(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNum: %w", err)
	}
	return oldValue.BlockNum, nil
}

// AddBlockNum adds u to the "block_num" field.
func (m *ContractMutation) AddBlockNum(u int64) {
	if m.addblock_num != nil {
		*m.addblock_num += u
	} else {
		m.addblock_num = &u
	}
}

// AddedBlockNum returns the value that was added to the "block_num" field in this mutation.
func (m *ContractMutation) AddedBlockNum() (r int64, exists bool) {
	v := m.addblock_num
	if v == nil {
		return
	}
	return *v, true
}

// ClearBlockNum clears the value of the "block_num" field.
func (m *ContractMutation) ClearBlockNum() {
	m.block_num = nil
	m.addblock_num = nil
	m.clearedFields[contract.FieldBlockNum] = struct{}{}
}

// BlockNumCleared returns if the "block_num" field was cleared in this mutation.
func (m *ContractMutation) BlockNumCleared() bool {
	_, ok := m.clearedFields[contract.FieldBlockNum]
	return ok
}

// ResetBlockNum resets all changes to the "block_num" field.
func (m *ContractMutation) ResetBlockNum() {
	m.block_num = nil
	m.addblock_num = nil
	delete(m.clearedFields, contract.FieldBlockNum)
}

// SetTxHash sets the "tx_hash" field.
func (m *ContractMutation) SetTxHash(s string) {
	m.tx_hash = &s
}

// TxHash returns the value of the "tx_hash" field in the mutation.
func (m *ContractMutation) TxHash() (r string, exists bool) {
	v := m.tx_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTxHash returns the old "tx_hash" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldTxHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxHash: %w", err)
	}
	return oldValue.TxHash, nil
}

// ClearTxHash clears the value of the "tx_hash" field.
func (m *ContractMutation) ClearTxHash() {
	m.tx_hash = nil
	m.clearedFields[contract.FieldTxHash] = struct{}{}
}

// TxHashCleared returns if the "tx_hash" field was cleared in this mutation.
func (m *ContractMutation) TxHashCleared() bool {
	_, ok := m.clearedFields[contract.FieldTxHash]
	return ok
}

// ResetTxHash resets all changes to the "tx_hash" field.
func (m *ContractMutation) ResetTxHash() {
	m.tx_hash = nil
	delete(m.clearedFields, contract.FieldTxHash)
}

// SetTxTime sets the "tx_time" field.
func (m *ContractMutation) SetTxTime(u uint32) {
	m.tx_time = &u
	m.addtx_time = nil
}

// TxTime returns the value of the "tx_time" field in the mutation.
func (m *ContractMutation) TxTime() (r uint32, exists bool) {
	v := m.tx_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTxTime returns the old "tx_time" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldTxTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxTime: %w", err)
	}
	return oldValue.TxTime, nil
}

// AddTxTime adds u to the "tx_time" field.
func (m *ContractMutation) AddTxTime(u int32) {
	if m.addtx_time != nil {
		*m.addtx_time += u
	} else {
		m.addtx_time = &u
	}
}

// AddedTxTime returns the value that was added to the "tx_time" field in this mutation.
func (m *ContractMutation) AddedTxTime() (r int32, exists bool) {
	v := m.addtx_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearTxTime clears the value of the "tx_time" field.
func (m *ContractMutation) ClearTxTime() {
	m.tx_time = nil
	m.addtx_time = nil
	m.clearedFields[contract.FieldTxTime] = struct{}{}
}

// TxTimeCleared returns if the "tx_time" field was cleared in this mutation.
func (m *ContractMutation) TxTimeCleared() bool {
	_, ok := m.clearedFields[contract.FieldTxTime]
	return ok
}

// ResetTxTime resets all changes to the "tx_time" field.
func (m *ContractMutation) ResetTxTime() {
	m.tx_time = nil
	m.addtx_time = nil
	delete(m.clearedFields, contract.FieldTxTime)
}

// SetProfileURL sets the "profile_url" field.
func (m *ContractMutation) SetProfileURL(s string) {
	m.profile_url = &s
}

// ProfileURL returns the value of the "profile_url" field in the mutation.
func (m *ContractMutation) ProfileURL() (r string, exists bool) {
	v := m.profile_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileURL returns the old "profile_url" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldProfileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileURL: %w", err)
	}
	return oldValue.ProfileURL, nil
}

// ClearProfileURL clears the value of the "profile_url" field.
func (m *ContractMutation) ClearProfileURL() {
	m.profile_url = nil
	m.clearedFields[contract.FieldProfileURL] = struct{}{}
}

// ProfileURLCleared returns if the "profile_url" field was cleared in this mutation.
func (m *ContractMutation) ProfileURLCleared() bool {
	_, ok := m.clearedFields[contract.FieldProfileURL]
	return ok
}

// ResetProfileURL resets all changes to the "profile_url" field.
func (m *ContractMutation) ResetProfileURL() {
	m.profile_url = nil
	delete(m.clearedFields, contract.FieldProfileURL)
}

// SetBaseURL sets the "base_url" field.
func (m *ContractMutation) SetBaseURL(s string) {
	m.base_url = &s
}

// BaseURL returns the value of the "base_url" field in the mutation.
func (m *ContractMutation) BaseURL() (r string, exists bool) {
	v := m.base_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseURL returns the old "base_url" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldBaseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseURL: %w", err)
	}
	return oldValue.BaseURL, nil
}

// ClearBaseURL clears the value of the "base_url" field.
func (m *ContractMutation) ClearBaseURL() {
	m.base_url = nil
	m.clearedFields[contract.FieldBaseURL] = struct{}{}
}

// BaseURLCleared returns if the "base_url" field was cleared in this mutation.
func (m *ContractMutation) BaseURLCleared() bool {
	_, ok := m.clearedFields[contract.FieldBaseURL]
	return ok
}

// ResetBaseURL resets all changes to the "base_url" field.
func (m *ContractMutation) ResetBaseURL() {
	m.base_url = nil
	delete(m.clearedFields, contract.FieldBaseURL)
}

// SetBannerURL sets the "banner_url" field.
func (m *ContractMutation) SetBannerURL(s string) {
	m.banner_url = &s
}

// BannerURL returns the value of the "banner_url" field in the mutation.
func (m *ContractMutation) BannerURL() (r string, exists bool) {
	v := m.banner_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerURL returns the old "banner_url" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldBannerURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerURL: %w", err)
	}
	return oldValue.BannerURL, nil
}

// ClearBannerURL clears the value of the "banner_url" field.
func (m *ContractMutation) ClearBannerURL() {
	m.banner_url = nil
	m.clearedFields[contract.FieldBannerURL] = struct{}{}
}

// BannerURLCleared returns if the "banner_url" field was cleared in this mutation.
func (m *ContractMutation) BannerURLCleared() bool {
	_, ok := m.clearedFields[contract.FieldBannerURL]
	return ok
}

// ResetBannerURL resets all changes to the "banner_url" field.
func (m *ContractMutation) ResetBannerURL() {
	m.banner_url = nil
	delete(m.clearedFields, contract.FieldBannerURL)
}

// SetDescription sets the "description" field.
func (m *ContractMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ContractMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ContractMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[contract.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ContractMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[contract.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ContractMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, contract.FieldDescription)
}

// SetRemark sets the "remark" field.
func (m *ContractMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ContractMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ContractMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[contract.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ContractMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[contract.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ContractMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, contract.FieldRemark)
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, contract.FieldDeletedAt)
	}
	if m.chain_type != nil {
		fields = append(fields, contract.FieldChainType)
	}
	if m.chain_id != nil {
		fields = append(fields, contract.FieldChainID)
	}
	if m.address != nil {
		fields = append(fields, contract.FieldAddress)
	}
	if m.name != nil {
		fields = append(fields, contract.FieldName)
	}
	if m.symbol != nil {
		fields = append(fields, contract.FieldSymbol)
	}
	if m.creator != nil {
		fields = append(fields, contract.FieldCreator)
	}
	if m.block_num != nil {
		fields = append(fields, contract.FieldBlockNum)
	}
	if m.tx_hash != nil {
		fields = append(fields, contract.FieldTxHash)
	}
	if m.tx_time != nil {
		fields = append(fields, contract.FieldTxTime)
	}
	if m.profile_url != nil {
		fields = append(fields, contract.FieldProfileURL)
	}
	if m.base_url != nil {
		fields = append(fields, contract.FieldBaseURL)
	}
	if m.banner_url != nil {
		fields = append(fields, contract.FieldBannerURL)
	}
	if m.description != nil {
		fields = append(fields, contract.FieldDescription)
	}
	if m.remark != nil {
		fields = append(fields, contract.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldCreatedAt:
		return m.CreatedAt()
	case contract.FieldUpdatedAt:
		return m.UpdatedAt()
	case contract.FieldDeletedAt:
		return m.DeletedAt()
	case contract.FieldChainType:
		return m.ChainType()
	case contract.FieldChainID:
		return m.ChainID()
	case contract.FieldAddress:
		return m.Address()
	case contract.FieldName:
		return m.Name()
	case contract.FieldSymbol:
		return m.Symbol()
	case contract.FieldCreator:
		return m.Creator()
	case contract.FieldBlockNum:
		return m.BlockNum()
	case contract.FieldTxHash:
		return m.TxHash()
	case contract.FieldTxTime:
		return m.TxTime()
	case contract.FieldProfileURL:
		return m.ProfileURL()
	case contract.FieldBaseURL:
		return m.BaseURL()
	case contract.FieldBannerURL:
		return m.BannerURL()
	case contract.FieldDescription:
		return m.Description()
	case contract.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contract.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case contract.FieldChainType:
		return m.OldChainType(ctx)
	case contract.FieldChainID:
		return m.OldChainID(ctx)
	case contract.FieldAddress:
		return m.OldAddress(ctx)
	case contract.FieldName:
		return m.OldName(ctx)
	case contract.FieldSymbol:
		return m.OldSymbol(ctx)
	case contract.FieldCreator:
		return m.OldCreator(ctx)
	case contract.FieldBlockNum:
		return m.OldBlockNum(ctx)
	case contract.FieldTxHash:
		return m.OldTxHash(ctx)
	case contract.FieldTxTime:
		return m.OldTxTime(ctx)
	case contract.FieldProfileURL:
		return m.OldProfileURL(ctx)
	case contract.FieldBaseURL:
		return m.OldBaseURL(ctx)
	case contract.FieldBannerURL:
		return m.OldBannerURL(ctx)
	case contract.FieldDescription:
		return m.OldDescription(ctx)
	case contract.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contract.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contract.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case contract.FieldChainType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainType(v)
		return nil
	case contract.FieldChainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case contract.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case contract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contract.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case contract.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case contract.FieldBlockNum:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNum(v)
		return nil
	case contract.FieldTxHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxHash(v)
		return nil
	case contract.FieldTxTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxTime(v)
		return nil
	case contract.FieldProfileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileURL(v)
		return nil
	case contract.FieldBaseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseURL(v)
		return nil
	case contract.FieldBannerURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerURL(v)
		return nil
	case contract.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case contract.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, contract.FieldDeletedAt)
	}
	if m.addblock_num != nil {
		fields = append(fields, contract.FieldBlockNum)
	}
	if m.addtx_time != nil {
		fields = append(fields, contract.FieldTxTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldCreatedAt:
		return m.AddedCreatedAt()
	case contract.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case contract.FieldDeletedAt:
		return m.AddedDeletedAt()
	case contract.FieldBlockNum:
		return m.AddedBlockNum()
	case contract.FieldTxTime:
		return m.AddedTxTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contract.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case contract.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case contract.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case contract.FieldBlockNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNum(v)
		return nil
	case contract.FieldTxTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTxTime(v)
		return nil
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contract.FieldCreator) {
		fields = append(fields, contract.FieldCreator)
	}
	if m.FieldCleared(contract.FieldBlockNum) {
		fields = append(fields, contract.FieldBlockNum)
	}
	if m.FieldCleared(contract.FieldTxHash) {
		fields = append(fields, contract.FieldTxHash)
	}
	if m.FieldCleared(contract.FieldTxTime) {
		fields = append(fields, contract.FieldTxTime)
	}
	if m.FieldCleared(contract.FieldProfileURL) {
		fields = append(fields, contract.FieldProfileURL)
	}
	if m.FieldCleared(contract.FieldBaseURL) {
		fields = append(fields, contract.FieldBaseURL)
	}
	if m.FieldCleared(contract.FieldBannerURL) {
		fields = append(fields, contract.FieldBannerURL)
	}
	if m.FieldCleared(contract.FieldDescription) {
		fields = append(fields, contract.FieldDescription)
	}
	if m.FieldCleared(contract.FieldRemark) {
		fields = append(fields, contract.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	switch name {
	case contract.FieldCreator:
		m.ClearCreator()
		return nil
	case contract.FieldBlockNum:
		m.ClearBlockNum()
		return nil
	case contract.FieldTxHash:
		m.ClearTxHash()
		return nil
	case contract.FieldTxTime:
		m.ClearTxTime()
		return nil
	case contract.FieldProfileURL:
		m.ClearProfileURL()
		return nil
	case contract.FieldBaseURL:
		m.ClearBaseURL()
		return nil
	case contract.FieldBannerURL:
		m.ClearBannerURL()
		return nil
	case contract.FieldDescription:
		m.ClearDescription()
		return nil
	case contract.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contract.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case contract.FieldChainType:
		m.ResetChainType()
		return nil
	case contract.FieldChainID:
		m.ResetChainID()
		return nil
	case contract.FieldAddress:
		m.ResetAddress()
		return nil
	case contract.FieldName:
		m.ResetName()
		return nil
	case contract.FieldSymbol:
		m.ResetSymbol()
		return nil
	case contract.FieldCreator:
		m.ResetCreator()
		return nil
	case contract.FieldBlockNum:
		m.ResetBlockNum()
		return nil
	case contract.FieldTxHash:
		m.ResetTxHash()
		return nil
	case contract.FieldTxTime:
		m.ResetTxTime()
		return nil
	case contract.FieldProfileURL:
		m.ResetProfileURL()
		return nil
	case contract.FieldBaseURL:
		m.ResetBaseURL()
		return nil
	case contract.FieldBannerURL:
		m.ResetBannerURL()
		return nil
	case contract.FieldDescription:
		m.ResetDescription()
		return nil
	case contract.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Contract edge %s", name)
}

// EndpointMutation represents an operation that mutates the Endpoint nodes in the graph.
type EndpointMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	chain_type    *string
	chain_id      *string
	address       *string
	state         *string
	remark        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Endpoint, error)
	predicates    []predicate.Endpoint
}

var _ ent.Mutation = (*EndpointMutation)(nil)

// endpointOption allows management of the mutation configuration using functional options.
type endpointOption func(*EndpointMutation)

// newEndpointMutation creates new mutation for the Endpoint entity.
func newEndpointMutation(c config, op Op, opts ...endpointOption) *EndpointMutation {
	m := &EndpointMutation{
		config:        c,
		op:            op,
		typ:           TypeEndpoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEndpointID sets the ID field of the mutation.
func withEndpointID(id uuid.UUID) endpointOption {
	return func(m *EndpointMutation) {
		var (
			err   error
			once  sync.Once
			value *Endpoint
		)
		m.oldValue = func(ctx context.Context) (*Endpoint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Endpoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEndpoint sets the old Endpoint of the mutation.
func withEndpoint(node *Endpoint) endpointOption {
	return func(m *EndpointMutation) {
		m.oldValue = func(context.Context) (*Endpoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EndpointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EndpointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Endpoint entities.
func (m *EndpointMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EndpointMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EndpointMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Endpoint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EndpointMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EndpointMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *EndpointMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EndpointMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EndpointMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EndpointMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EndpointMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *EndpointMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EndpointMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EndpointMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EndpointMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EndpointMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *EndpointMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *EndpointMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EndpointMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetChainType sets the "chain_type" field.
func (m *EndpointMutation) SetChainType(s string) {
	m.chain_type = &s
}

// ChainType returns the value of the "chain_type" field in the mutation.
func (m *EndpointMutation) ChainType() (r string, exists bool) {
	v := m.chain_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChainType returns the old "chain_type" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldChainType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainType: %w", err)
	}
	return oldValue.ChainType, nil
}

// ResetChainType resets all changes to the "chain_type" field.
func (m *EndpointMutation) ResetChainType() {
	m.chain_type = nil
}

// SetChainID sets the "chain_id" field.
func (m *EndpointMutation) SetChainID(s string) {
	m.chain_id = &s
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *EndpointMutation) ChainID() (r string, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldChainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// ClearChainID clears the value of the "chain_id" field.
func (m *EndpointMutation) ClearChainID() {
	m.chain_id = nil
	m.clearedFields[endpoint.FieldChainID] = struct{}{}
}

// ChainIDCleared returns if the "chain_id" field was cleared in this mutation.
func (m *EndpointMutation) ChainIDCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldChainID]
	return ok
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *EndpointMutation) ResetChainID() {
	m.chain_id = nil
	delete(m.clearedFields, endpoint.FieldChainID)
}

// SetAddress sets the "address" field.
func (m *EndpointMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *EndpointMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *EndpointMutation) ResetAddress() {
	m.address = nil
}

// SetState sets the "state" field.
func (m *EndpointMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *EndpointMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *EndpointMutation) ClearState() {
	m.state = nil
	m.clearedFields[endpoint.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *EndpointMutation) StateCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *EndpointMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, endpoint.FieldState)
}

// SetRemark sets the "remark" field.
func (m *EndpointMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EndpointMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EndpointMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[endpoint.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EndpointMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EndpointMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, endpoint.FieldRemark)
}

// Where appends a list predicates to the EndpointMutation builder.
func (m *EndpointMutation) Where(ps ...predicate.Endpoint) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EndpointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Endpoint).
func (m *EndpointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EndpointMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, endpoint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, endpoint.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, endpoint.FieldDeletedAt)
	}
	if m.chain_type != nil {
		fields = append(fields, endpoint.FieldChainType)
	}
	if m.chain_id != nil {
		fields = append(fields, endpoint.FieldChainID)
	}
	if m.address != nil {
		fields = append(fields, endpoint.FieldAddress)
	}
	if m.state != nil {
		fields = append(fields, endpoint.FieldState)
	}
	if m.remark != nil {
		fields = append(fields, endpoint.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EndpointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case endpoint.FieldCreatedAt:
		return m.CreatedAt()
	case endpoint.FieldUpdatedAt:
		return m.UpdatedAt()
	case endpoint.FieldDeletedAt:
		return m.DeletedAt()
	case endpoint.FieldChainType:
		return m.ChainType()
	case endpoint.FieldChainID:
		return m.ChainID()
	case endpoint.FieldAddress:
		return m.Address()
	case endpoint.FieldState:
		return m.State()
	case endpoint.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EndpointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case endpoint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case endpoint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case endpoint.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case endpoint.FieldChainType:
		return m.OldChainType(ctx)
	case endpoint.FieldChainID:
		return m.OldChainID(ctx)
	case endpoint.FieldAddress:
		return m.OldAddress(ctx)
	case endpoint.FieldState:
		return m.OldState(ctx)
	case endpoint.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Endpoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EndpointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case endpoint.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case endpoint.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case endpoint.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case endpoint.FieldChainType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainType(v)
		return nil
	case endpoint.FieldChainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case endpoint.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case endpoint.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case endpoint.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Endpoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EndpointMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, endpoint.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, endpoint.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, endpoint.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EndpointMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case endpoint.FieldCreatedAt:
		return m.AddedCreatedAt()
	case endpoint.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case endpoint.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EndpointMutation) AddField(name string, value ent.Value) error {
	switch name {
	case endpoint.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case endpoint.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case endpoint.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Endpoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EndpointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(endpoint.FieldChainID) {
		fields = append(fields, endpoint.FieldChainID)
	}
	if m.FieldCleared(endpoint.FieldState) {
		fields = append(fields, endpoint.FieldState)
	}
	if m.FieldCleared(endpoint.FieldRemark) {
		fields = append(fields, endpoint.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EndpointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EndpointMutation) ClearField(name string) error {
	switch name {
	case endpoint.FieldChainID:
		m.ClearChainID()
		return nil
	case endpoint.FieldState:
		m.ClearState()
		return nil
	case endpoint.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Endpoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EndpointMutation) ResetField(name string) error {
	switch name {
	case endpoint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case endpoint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case endpoint.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case endpoint.FieldChainType:
		m.ResetChainType()
		return nil
	case endpoint.FieldChainID:
		m.ResetChainID()
		return nil
	case endpoint.FieldAddress:
		m.ResetAddress()
		return nil
	case endpoint.FieldState:
		m.ResetState()
		return nil
	case endpoint.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Endpoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EndpointMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EndpointMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EndpointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EndpointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EndpointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EndpointMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EndpointMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Endpoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EndpointMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Endpoint edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	contract       *string
	token_type     *string
	token_id       *string
	amount         *uint64
	addamount      *int64
	portion_num    *uint32
	addportion_num *int32
	remark         *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*OrderItem, error)
	predicates     []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id uuid.UUID) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderItem entities.
func (m *OrderItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *OrderItemMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *OrderItemMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *OrderItemMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *OrderItemMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderItemMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderItemMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *OrderItemMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderItemMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetContract sets the "contract" field.
func (m *OrderItemMutation) SetContract(s string) {
	m.contract = &s
}

// Contract returns the value of the "contract" field in the mutation.
func (m *OrderItemMutation) Contract() (r string, exists bool) {
	v := m.contract
	if v == nil {
		return
	}
	return *v, true
}

// OldContract returns the old "contract" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldContract(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContract is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContract requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContract: %w", err)
	}
	return oldValue.Contract, nil
}

// ResetContract resets all changes to the "contract" field.
func (m *OrderItemMutation) ResetContract() {
	m.contract = nil
}

// SetTokenType sets the "token_type" field.
func (m *OrderItemMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *OrderItemMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *OrderItemMutation) ResetTokenType() {
	m.token_type = nil
}

// SetTokenID sets the "token_id" field.
func (m *OrderItemMutation) SetTokenID(s string) {
	m.token_id = &s
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *OrderItemMutation) TokenID() (r string, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *OrderItemMutation) ResetTokenID() {
	m.token_id = nil
}

// SetAmount sets the "amount" field.
func (m *OrderItemMutation) SetAmount(u uint64) {
	m.amount = &u
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderItemMutation) Amount() (r uint64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldAmount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds u to the "amount" field.
func (m *OrderItemMutation) AddAmount(u int64) {
	if m.addamount != nil {
		*m.addamount += u
	} else {
		m.addamount = &u
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *OrderItemMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderItemMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPortionNum sets the "portion_num" field.
func (m *OrderItemMutation) SetPortionNum(u uint32) {
	m.portion_num = &u
	m.addportion_num = nil
}

// PortionNum returns the value of the "portion_num" field in the mutation.
func (m *OrderItemMutation) PortionNum() (r uint32, exists bool) {
	v := m.portion_num
	if v == nil {
		return
	}
	return *v, true
}

// OldPortionNum returns the old "portion_num" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldPortionNum(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPortionNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPortionNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPortionNum: %w", err)
	}
	return oldValue.PortionNum, nil
}

// AddPortionNum adds u to the "portion_num" field.
func (m *OrderItemMutation) AddPortionNum(u int32) {
	if m.addportion_num != nil {
		*m.addportion_num += u
	} else {
		m.addportion_num = &u
	}
}

// AddedPortionNum returns the value that was added to the "portion_num" field in this mutation.
func (m *OrderItemMutation) AddedPortionNum() (r int32, exists bool) {
	v := m.addportion_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetPortionNum resets all changes to the "portion_num" field.
func (m *OrderItemMutation) ResetPortionNum() {
	m.portion_num = nil
	m.addportion_num = nil
}

// SetRemark sets the "remark" field.
func (m *OrderItemMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderItemMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrderItemMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[orderitem.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrderItemMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderItemMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, orderitem.FieldRemark)
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderitem.FieldDeletedAt)
	}
	if m.contract != nil {
		fields = append(fields, orderitem.FieldContract)
	}
	if m.token_type != nil {
		fields = append(fields, orderitem.FieldTokenType)
	}
	if m.token_id != nil {
		fields = append(fields, orderitem.FieldTokenID)
	}
	if m.amount != nil {
		fields = append(fields, orderitem.FieldAmount)
	}
	if m.portion_num != nil {
		fields = append(fields, orderitem.FieldPortionNum)
	}
	if m.remark != nil {
		fields = append(fields, orderitem.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitem.FieldDeletedAt:
		return m.DeletedAt()
	case orderitem.FieldContract:
		return m.Contract()
	case orderitem.FieldTokenType:
		return m.TokenType()
	case orderitem.FieldTokenID:
		return m.TokenID()
	case orderitem.FieldAmount:
		return m.Amount()
	case orderitem.FieldPortionNum:
		return m.PortionNum()
	case orderitem.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderitem.FieldContract:
		return m.OldContract(ctx)
	case orderitem.FieldTokenType:
		return m.OldTokenType(ctx)
	case orderitem.FieldTokenID:
		return m.OldTokenID(ctx)
	case orderitem.FieldAmount:
		return m.OldAmount(ctx)
	case orderitem.FieldPortionNum:
		return m.OldPortionNum(ctx)
	case orderitem.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitem.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderitem.FieldContract:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContract(v)
		return nil
	case orderitem.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case orderitem.FieldTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case orderitem.FieldAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case orderitem.FieldPortionNum:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPortionNum(v)
		return nil
	case orderitem.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, orderitem.FieldDeletedAt)
	}
	if m.addamount != nil {
		fields = append(fields, orderitem.FieldAmount)
	}
	if m.addportion_num != nil {
		fields = append(fields, orderitem.FieldPortionNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.AddedCreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case orderitem.FieldDeletedAt:
		return m.AddedDeletedAt()
	case orderitem.FieldAmount:
		return m.AddedAmount()
	case orderitem.FieldPortionNum:
		return m.AddedPortionNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case orderitem.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case orderitem.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case orderitem.FieldPortionNum:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPortionNum(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldRemark) {
		fields = append(fields, orderitem.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderitem.FieldContract:
		m.ResetContract()
		return nil
	case orderitem.FieldTokenType:
		m.ResetTokenType()
		return nil
	case orderitem.FieldTokenID:
		m.ResetTokenID()
		return nil
	case orderitem.FieldAmount:
		m.ResetAmount()
		return nil
	case orderitem.FieldPortionNum:
		m.ResetPortionNum()
		return nil
	case orderitem.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// OrderPairMutation represents an operation that mutates the OrderPair nodes in the graph.
type OrderPairMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	tx_hash       *string
	recipient     *string
	target_id     *string
	offer_id      *string
	remark        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OrderPair, error)
	predicates    []predicate.OrderPair
}

var _ ent.Mutation = (*OrderPairMutation)(nil)

// orderpairOption allows management of the mutation configuration using functional options.
type orderpairOption func(*OrderPairMutation)

// newOrderPairMutation creates new mutation for the OrderPair entity.
func newOrderPairMutation(c config, op Op, opts ...orderpairOption) *OrderPairMutation {
	m := &OrderPairMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderPair,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderPairID sets the ID field of the mutation.
func withOrderPairID(id uuid.UUID) orderpairOption {
	return func(m *OrderPairMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderPair
		)
		m.oldValue = func(ctx context.Context) (*OrderPair, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderPair.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderPair sets the old OrderPair of the mutation.
func withOrderPair(node *OrderPair) orderpairOption {
	return func(m *OrderPairMutation) {
		m.oldValue = func(context.Context) (*OrderPair, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderPairMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderPairMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderPair entities.
func (m *OrderPairMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderPairMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderPairMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderPair.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderPairMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderPairMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderPair entity.
// If the OrderPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPairMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *OrderPairMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *OrderPairMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderPairMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderPairMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderPairMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderPair entity.
// If the OrderPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPairMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *OrderPairMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *OrderPairMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderPairMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderPairMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderPairMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderPair entity.
// If the OrderPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPairMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *OrderPairMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderPairMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderPairMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTxHash sets the "tx_hash" field.
func (m *OrderPairMutation) SetTxHash(s string) {
	m.tx_hash = &s
}

// TxHash returns the value of the "tx_hash" field in the mutation.
func (m *OrderPairMutation) TxHash() (r string, exists bool) {
	v := m.tx_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTxHash returns the old "tx_hash" field's value of the OrderPair entity.
// If the OrderPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPairMutation) OldTxHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxHash: %w", err)
	}
	return oldValue.TxHash, nil
}

// ResetTxHash resets all changes to the "tx_hash" field.
func (m *OrderPairMutation) ResetTxHash() {
	m.tx_hash = nil
}

// SetRecipient sets the "recipient" field.
func (m *OrderPairMutation) SetRecipient(s string) {
	m.recipient = &s
}

// Recipient returns the value of the "recipient" field in the mutation.
func (m *OrderPairMutation) Recipient() (r string, exists bool) {
	v := m.recipient
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipient returns the old "recipient" field's value of the OrderPair entity.
// If the OrderPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPairMutation) OldRecipient(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipient is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipient requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipient: %w", err)
	}
	return oldValue.Recipient, nil
}

// ResetRecipient resets all changes to the "recipient" field.
func (m *OrderPairMutation) ResetRecipient() {
	m.recipient = nil
}

// SetTargetID sets the "target_id" field.
func (m *OrderPairMutation) SetTargetID(s string) {
	m.target_id = &s
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *OrderPairMutation) TargetID() (r string, exists bool) {
	v := m.target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the OrderPair entity.
// If the OrderPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPairMutation) OldTargetID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *OrderPairMutation) ResetTargetID() {
	m.target_id = nil
}

// SetOfferID sets the "offer_id" field.
func (m *OrderPairMutation) SetOfferID(s string) {
	m.offer_id = &s
}

// OfferID returns the value of the "offer_id" field in the mutation.
func (m *OrderPairMutation) OfferID() (r string, exists bool) {
	v := m.offer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOfferID returns the old "offer_id" field's value of the OrderPair entity.
// If the OrderPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPairMutation) OldOfferID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfferID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfferID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfferID: %w", err)
	}
	return oldValue.OfferID, nil
}

// ResetOfferID resets all changes to the "offer_id" field.
func (m *OrderPairMutation) ResetOfferID() {
	m.offer_id = nil
}

// SetRemark sets the "remark" field.
func (m *OrderPairMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderPairMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OrderPair entity.
// If the OrderPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPairMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrderPairMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[orderpair.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrderPairMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[orderpair.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderPairMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, orderpair.FieldRemark)
}

// Where appends a list predicates to the OrderPairMutation builder.
func (m *OrderPairMutation) Where(ps ...predicate.OrderPair) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderPairMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderPair).
func (m *OrderPairMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderPairMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, orderpair.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderpair.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderpair.FieldDeletedAt)
	}
	if m.tx_hash != nil {
		fields = append(fields, orderpair.FieldTxHash)
	}
	if m.recipient != nil {
		fields = append(fields, orderpair.FieldRecipient)
	}
	if m.target_id != nil {
		fields = append(fields, orderpair.FieldTargetID)
	}
	if m.offer_id != nil {
		fields = append(fields, orderpair.FieldOfferID)
	}
	if m.remark != nil {
		fields = append(fields, orderpair.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderPairMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderpair.FieldCreatedAt:
		return m.CreatedAt()
	case orderpair.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderpair.FieldDeletedAt:
		return m.DeletedAt()
	case orderpair.FieldTxHash:
		return m.TxHash()
	case orderpair.FieldRecipient:
		return m.Recipient()
	case orderpair.FieldTargetID:
		return m.TargetID()
	case orderpair.FieldOfferID:
		return m.OfferID()
	case orderpair.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderPairMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderpair.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderpair.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderpair.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderpair.FieldTxHash:
		return m.OldTxHash(ctx)
	case orderpair.FieldRecipient:
		return m.OldRecipient(ctx)
	case orderpair.FieldTargetID:
		return m.OldTargetID(ctx)
	case orderpair.FieldOfferID:
		return m.OldOfferID(ctx)
	case orderpair.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown OrderPair field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPairMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderpair.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderpair.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderpair.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderpair.FieldTxHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxHash(v)
		return nil
	case orderpair.FieldRecipient:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipient(v)
		return nil
	case orderpair.FieldTargetID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case orderpair.FieldOfferID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfferID(v)
		return nil
	case orderpair.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPair field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderPairMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, orderpair.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, orderpair.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, orderpair.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderPairMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderpair.FieldCreatedAt:
		return m.AddedCreatedAt()
	case orderpair.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case orderpair.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPairMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderpair.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case orderpair.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case orderpair.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPair numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderPairMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderpair.FieldRemark) {
		fields = append(fields, orderpair.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderPairMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderPairMutation) ClearField(name string) error {
	switch name {
	case orderpair.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown OrderPair nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderPairMutation) ResetField(name string) error {
	switch name {
	case orderpair.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderpair.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderpair.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderpair.FieldTxHash:
		m.ResetTxHash()
		return nil
	case orderpair.FieldRecipient:
		m.ResetRecipient()
		return nil
	case orderpair.FieldTargetID:
		m.ResetTargetID()
		return nil
	case orderpair.FieldOfferID:
		m.ResetOfferID()
		return nil
	case orderpair.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown OrderPair field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderPairMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderPairMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderPairMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderPairMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderPairMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderPairMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderPairMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderPair unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderPairMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderPair edge %s", name)
}

// SnapshotMutation represents an operation that mutates the Snapshot nodes in the graph.
type SnapshotMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	index           *uint64
	addindex        *int64
	snapshot_comm_p *string
	snapshot_root   *string
	snapshot_uri    *string
	backup_state    *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Snapshot, error)
	predicates      []predicate.Snapshot
}

var _ ent.Mutation = (*SnapshotMutation)(nil)

// snapshotOption allows management of the mutation configuration using functional options.
type snapshotOption func(*SnapshotMutation)

// newSnapshotMutation creates new mutation for the Snapshot entity.
func newSnapshotMutation(c config, op Op, opts ...snapshotOption) *SnapshotMutation {
	m := &SnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSnapshotID sets the ID field of the mutation.
func withSnapshotID(id uuid.UUID) snapshotOption {
	return func(m *SnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *Snapshot
		)
		m.oldValue = func(ctx context.Context) (*Snapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Snapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSnapshot sets the old Snapshot of the mutation.
func withSnapshot(node *Snapshot) snapshotOption {
	return func(m *SnapshotMutation) {
		m.oldValue = func(context.Context) (*Snapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Snapshot entities.
func (m *SnapshotMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SnapshotMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SnapshotMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Snapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SnapshotMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SnapshotMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *SnapshotMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SnapshotMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SnapshotMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SnapshotMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *SnapshotMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *SnapshotMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SnapshotMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SnapshotMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SnapshotMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *SnapshotMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SnapshotMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SnapshotMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetIndex sets the "index" field.
func (m *SnapshotMutation) SetIndex(u uint64) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *SnapshotMutation) Index() (r uint64, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldIndex(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *SnapshotMutation) AddIndex(u int64) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *SnapshotMutation) AddedIndex() (r int64, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *SnapshotMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetSnapshotCommP sets the "snapshot_comm_p" field.
func (m *SnapshotMutation) SetSnapshotCommP(s string) {
	m.snapshot_comm_p = &s
}

// SnapshotCommP returns the value of the "snapshot_comm_p" field in the mutation.
func (m *SnapshotMutation) SnapshotCommP() (r string, exists bool) {
	v := m.snapshot_comm_p
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshotCommP returns the old "snapshot_comm_p" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldSnapshotCommP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshotCommP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshotCommP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshotCommP: %w", err)
	}
	return oldValue.SnapshotCommP, nil
}

// ResetSnapshotCommP resets all changes to the "snapshot_comm_p" field.
func (m *SnapshotMutation) ResetSnapshotCommP() {
	m.snapshot_comm_p = nil
}

// SetSnapshotRoot sets the "snapshot_root" field.
func (m *SnapshotMutation) SetSnapshotRoot(s string) {
	m.snapshot_root = &s
}

// SnapshotRoot returns the value of the "snapshot_root" field in the mutation.
func (m *SnapshotMutation) SnapshotRoot() (r string, exists bool) {
	v := m.snapshot_root
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshotRoot returns the old "snapshot_root" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldSnapshotRoot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshotRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshotRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshotRoot: %w", err)
	}
	return oldValue.SnapshotRoot, nil
}

// ResetSnapshotRoot resets all changes to the "snapshot_root" field.
func (m *SnapshotMutation) ResetSnapshotRoot() {
	m.snapshot_root = nil
}

// SetSnapshotURI sets the "snapshot_uri" field.
func (m *SnapshotMutation) SetSnapshotURI(s string) {
	m.snapshot_uri = &s
}

// SnapshotURI returns the value of the "snapshot_uri" field in the mutation.
func (m *SnapshotMutation) SnapshotURI() (r string, exists bool) {
	v := m.snapshot_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshotURI returns the old "snapshot_uri" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldSnapshotURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshotURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshotURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshotURI: %w", err)
	}
	return oldValue.SnapshotURI, nil
}

// ResetSnapshotURI resets all changes to the "snapshot_uri" field.
func (m *SnapshotMutation) ResetSnapshotURI() {
	m.snapshot_uri = nil
}

// SetBackupState sets the "backup_state" field.
func (m *SnapshotMutation) SetBackupState(s string) {
	m.backup_state = &s
}

// BackupState returns the value of the "backup_state" field in the mutation.
func (m *SnapshotMutation) BackupState() (r string, exists bool) {
	v := m.backup_state
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupState returns the old "backup_state" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldBackupState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupState: %w", err)
	}
	return oldValue.BackupState, nil
}

// ResetBackupState resets all changes to the "backup_state" field.
func (m *SnapshotMutation) ResetBackupState() {
	m.backup_state = nil
}

// Where appends a list predicates to the SnapshotMutation builder.
func (m *SnapshotMutation) Where(ps ...predicate.Snapshot) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SnapshotMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Snapshot).
func (m *SnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SnapshotMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, snapshot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, snapshot.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, snapshot.FieldDeletedAt)
	}
	if m.index != nil {
		fields = append(fields, snapshot.FieldIndex)
	}
	if m.snapshot_comm_p != nil {
		fields = append(fields, snapshot.FieldSnapshotCommP)
	}
	if m.snapshot_root != nil {
		fields = append(fields, snapshot.FieldSnapshotRoot)
	}
	if m.snapshot_uri != nil {
		fields = append(fields, snapshot.FieldSnapshotURI)
	}
	if m.backup_state != nil {
		fields = append(fields, snapshot.FieldBackupState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case snapshot.FieldCreatedAt:
		return m.CreatedAt()
	case snapshot.FieldUpdatedAt:
		return m.UpdatedAt()
	case snapshot.FieldDeletedAt:
		return m.DeletedAt()
	case snapshot.FieldIndex:
		return m.Index()
	case snapshot.FieldSnapshotCommP:
		return m.SnapshotCommP()
	case snapshot.FieldSnapshotRoot:
		return m.SnapshotRoot()
	case snapshot.FieldSnapshotURI:
		return m.SnapshotURI()
	case snapshot.FieldBackupState:
		return m.BackupState()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case snapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case snapshot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case snapshot.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case snapshot.FieldIndex:
		return m.OldIndex(ctx)
	case snapshot.FieldSnapshotCommP:
		return m.OldSnapshotCommP(ctx)
	case snapshot.FieldSnapshotRoot:
		return m.OldSnapshotRoot(ctx)
	case snapshot.FieldSnapshotURI:
		return m.OldSnapshotURI(ctx)
	case snapshot.FieldBackupState:
		return m.OldBackupState(ctx)
	}
	return nil, fmt.Errorf("unknown Snapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case snapshot.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case snapshot.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case snapshot.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case snapshot.FieldIndex:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case snapshot.FieldSnapshotCommP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshotCommP(v)
		return nil
	case snapshot.FieldSnapshotRoot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshotRoot(v)
		return nil
	case snapshot.FieldSnapshotURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshotURI(v)
		return nil
	case snapshot.FieldBackupState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupState(v)
		return nil
	}
	return fmt.Errorf("unknown Snapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, snapshot.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, snapshot.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, snapshot.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, snapshot.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case snapshot.FieldCreatedAt:
		return m.AddedCreatedAt()
	case snapshot.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case snapshot.FieldDeletedAt:
		return m.AddedDeletedAt()
	case snapshot.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case snapshot.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case snapshot.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case snapshot.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case snapshot.FieldIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Snapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SnapshotMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SnapshotMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Snapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SnapshotMutation) ResetField(name string) error {
	switch name {
	case snapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case snapshot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case snapshot.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case snapshot.FieldIndex:
		m.ResetIndex()
		return nil
	case snapshot.FieldSnapshotCommP:
		m.ResetSnapshotCommP()
		return nil
	case snapshot.FieldSnapshotRoot:
		m.ResetSnapshotRoot()
		return nil
	case snapshot.FieldSnapshotURI:
		m.ResetSnapshotURI()
		return nil
	case snapshot.FieldBackupState:
		m.ResetBackupState()
		return nil
	}
	return fmt.Errorf("unknown Snapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SnapshotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SnapshotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SnapshotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Snapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SnapshotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Snapshot edge %s", name)
}

// SyncTaskMutation represents an operation that mutates the SyncTask nodes in the graph.
type SyncTaskMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	chain_type    *string
	chain_id      *string
	start         *uint64
	addstart      *int64
	end           *uint64
	addend        *int64
	current       *uint64
	addcurrent    *int64
	topic         *string
	description   *string
	sync_state    *string
	remark        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SyncTask, error)
	predicates    []predicate.SyncTask
}

var _ ent.Mutation = (*SyncTaskMutation)(nil)

// synctaskOption allows management of the mutation configuration using functional options.
type synctaskOption func(*SyncTaskMutation)

// newSyncTaskMutation creates new mutation for the SyncTask entity.
func newSyncTaskMutation(c config, op Op, opts ...synctaskOption) *SyncTaskMutation {
	m := &SyncTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeSyncTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSyncTaskID sets the ID field of the mutation.
func withSyncTaskID(id uuid.UUID) synctaskOption {
	return func(m *SyncTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *SyncTask
		)
		m.oldValue = func(ctx context.Context) (*SyncTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SyncTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSyncTask sets the old SyncTask of the mutation.
func withSyncTask(node *SyncTask) synctaskOption {
	return func(m *SyncTaskMutation) {
		m.oldValue = func(context.Context) (*SyncTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SyncTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SyncTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SyncTask entities.
func (m *SyncTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SyncTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SyncTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SyncTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SyncTaskMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SyncTaskMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *SyncTaskMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SyncTaskMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SyncTaskMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SyncTaskMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SyncTaskMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *SyncTaskMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *SyncTaskMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SyncTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SyncTaskMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SyncTaskMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *SyncTaskMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SyncTaskMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SyncTaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetChainType sets the "chain_type" field.
func (m *SyncTaskMutation) SetChainType(s string) {
	m.chain_type = &s
}

// ChainType returns the value of the "chain_type" field in the mutation.
func (m *SyncTaskMutation) ChainType() (r string, exists bool) {
	v := m.chain_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChainType returns the old "chain_type" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldChainType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainType: %w", err)
	}
	return oldValue.ChainType, nil
}

// ClearChainType clears the value of the "chain_type" field.
func (m *SyncTaskMutation) ClearChainType() {
	m.chain_type = nil
	m.clearedFields[synctask.FieldChainType] = struct{}{}
}

// ChainTypeCleared returns if the "chain_type" field was cleared in this mutation.
func (m *SyncTaskMutation) ChainTypeCleared() bool {
	_, ok := m.clearedFields[synctask.FieldChainType]
	return ok
}

// ResetChainType resets all changes to the "chain_type" field.
func (m *SyncTaskMutation) ResetChainType() {
	m.chain_type = nil
	delete(m.clearedFields, synctask.FieldChainType)
}

// SetChainID sets the "chain_id" field.
func (m *SyncTaskMutation) SetChainID(s string) {
	m.chain_id = &s
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *SyncTaskMutation) ChainID() (r string, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldChainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *SyncTaskMutation) ResetChainID() {
	m.chain_id = nil
}

// SetStart sets the "start" field.
func (m *SyncTaskMutation) SetStart(u uint64) {
	m.start = &u
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *SyncTaskMutation) Start() (r uint64, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldStart(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds u to the "start" field.
func (m *SyncTaskMutation) AddStart(u int64) {
	if m.addstart != nil {
		*m.addstart += u
	} else {
		m.addstart = &u
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *SyncTaskMutation) AddedStart() (r int64, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *SyncTaskMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *SyncTaskMutation) SetEnd(u uint64) {
	m.end = &u
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *SyncTaskMutation) End() (r uint64, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldEnd(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds u to the "end" field.
func (m *SyncTaskMutation) AddEnd(u int64) {
	if m.addend != nil {
		*m.addend += u
	} else {
		m.addend = &u
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *SyncTaskMutation) AddedEnd() (r int64, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *SyncTaskMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetCurrent sets the "current" field.
func (m *SyncTaskMutation) SetCurrent(u uint64) {
	m.current = &u
	m.addcurrent = nil
}

// Current returns the value of the "current" field in the mutation.
func (m *SyncTaskMutation) Current() (r uint64, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "current" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldCurrent(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// AddCurrent adds u to the "current" field.
func (m *SyncTaskMutation) AddCurrent(u int64) {
	if m.addcurrent != nil {
		*m.addcurrent += u
	} else {
		m.addcurrent = &u
	}
}

// AddedCurrent returns the value that was added to the "current" field in this mutation.
func (m *SyncTaskMutation) AddedCurrent() (r int64, exists bool) {
	v := m.addcurrent
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrent resets all changes to the "current" field.
func (m *SyncTaskMutation) ResetCurrent() {
	m.current = nil
	m.addcurrent = nil
}

// SetTopic sets the "topic" field.
func (m *SyncTaskMutation) SetTopic(s string) {
	m.topic = &s
}

// Topic returns the value of the "topic" field in the mutation.
func (m *SyncTaskMutation) Topic() (r string, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic returns the old "topic" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldTopic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic: %w", err)
	}
	return oldValue.Topic, nil
}

// ResetTopic resets all changes to the "topic" field.
func (m *SyncTaskMutation) ResetTopic() {
	m.topic = nil
}

// SetDescription sets the "description" field.
func (m *SyncTaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SyncTaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SyncTaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[synctask.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SyncTaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[synctask.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SyncTaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, synctask.FieldDescription)
}

// SetSyncState sets the "sync_state" field.
func (m *SyncTaskMutation) SetSyncState(s string) {
	m.sync_state = &s
}

// SyncState returns the value of the "sync_state" field in the mutation.
func (m *SyncTaskMutation) SyncState() (r string, exists bool) {
	v := m.sync_state
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncState returns the old "sync_state" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldSyncState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncState: %w", err)
	}
	return oldValue.SyncState, nil
}

// ClearSyncState clears the value of the "sync_state" field.
func (m *SyncTaskMutation) ClearSyncState() {
	m.sync_state = nil
	m.clearedFields[synctask.FieldSyncState] = struct{}{}
}

// SyncStateCleared returns if the "sync_state" field was cleared in this mutation.
func (m *SyncTaskMutation) SyncStateCleared() bool {
	_, ok := m.clearedFields[synctask.FieldSyncState]
	return ok
}

// ResetSyncState resets all changes to the "sync_state" field.
func (m *SyncTaskMutation) ResetSyncState() {
	m.sync_state = nil
	delete(m.clearedFields, synctask.FieldSyncState)
}

// SetRemark sets the "remark" field.
func (m *SyncTaskMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SyncTaskMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the SyncTask entity.
// If the SyncTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncTaskMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SyncTaskMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[synctask.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SyncTaskMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[synctask.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SyncTaskMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, synctask.FieldRemark)
}

// Where appends a list predicates to the SyncTaskMutation builder.
func (m *SyncTaskMutation) Where(ps ...predicate.SyncTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SyncTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SyncTask).
func (m *SyncTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SyncTaskMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, synctask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, synctask.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, synctask.FieldDeletedAt)
	}
	if m.chain_type != nil {
		fields = append(fields, synctask.FieldChainType)
	}
	if m.chain_id != nil {
		fields = append(fields, synctask.FieldChainID)
	}
	if m.start != nil {
		fields = append(fields, synctask.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, synctask.FieldEnd)
	}
	if m.current != nil {
		fields = append(fields, synctask.FieldCurrent)
	}
	if m.topic != nil {
		fields = append(fields, synctask.FieldTopic)
	}
	if m.description != nil {
		fields = append(fields, synctask.FieldDescription)
	}
	if m.sync_state != nil {
		fields = append(fields, synctask.FieldSyncState)
	}
	if m.remark != nil {
		fields = append(fields, synctask.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SyncTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case synctask.FieldCreatedAt:
		return m.CreatedAt()
	case synctask.FieldUpdatedAt:
		return m.UpdatedAt()
	case synctask.FieldDeletedAt:
		return m.DeletedAt()
	case synctask.FieldChainType:
		return m.ChainType()
	case synctask.FieldChainID:
		return m.ChainID()
	case synctask.FieldStart:
		return m.Start()
	case synctask.FieldEnd:
		return m.End()
	case synctask.FieldCurrent:
		return m.Current()
	case synctask.FieldTopic:
		return m.Topic()
	case synctask.FieldDescription:
		return m.Description()
	case synctask.FieldSyncState:
		return m.SyncState()
	case synctask.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SyncTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case synctask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case synctask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case synctask.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case synctask.FieldChainType:
		return m.OldChainType(ctx)
	case synctask.FieldChainID:
		return m.OldChainID(ctx)
	case synctask.FieldStart:
		return m.OldStart(ctx)
	case synctask.FieldEnd:
		return m.OldEnd(ctx)
	case synctask.FieldCurrent:
		return m.OldCurrent(ctx)
	case synctask.FieldTopic:
		return m.OldTopic(ctx)
	case synctask.FieldDescription:
		return m.OldDescription(ctx)
	case synctask.FieldSyncState:
		return m.OldSyncState(ctx)
	case synctask.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown SyncTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case synctask.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case synctask.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case synctask.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case synctask.FieldChainType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainType(v)
		return nil
	case synctask.FieldChainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case synctask.FieldStart:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case synctask.FieldEnd:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case synctask.FieldCurrent:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	case synctask.FieldTopic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic(v)
		return nil
	case synctask.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case synctask.FieldSyncState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncState(v)
		return nil
	case synctask.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown SyncTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SyncTaskMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, synctask.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, synctask.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, synctask.FieldDeletedAt)
	}
	if m.addstart != nil {
		fields = append(fields, synctask.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, synctask.FieldEnd)
	}
	if m.addcurrent != nil {
		fields = append(fields, synctask.FieldCurrent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SyncTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case synctask.FieldCreatedAt:
		return m.AddedCreatedAt()
	case synctask.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case synctask.FieldDeletedAt:
		return m.AddedDeletedAt()
	case synctask.FieldStart:
		return m.AddedStart()
	case synctask.FieldEnd:
		return m.AddedEnd()
	case synctask.FieldCurrent:
		return m.AddedCurrent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case synctask.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case synctask.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case synctask.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case synctask.FieldStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case synctask.FieldEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	case synctask.FieldCurrent:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrent(v)
		return nil
	}
	return fmt.Errorf("unknown SyncTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SyncTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(synctask.FieldChainType) {
		fields = append(fields, synctask.FieldChainType)
	}
	if m.FieldCleared(synctask.FieldDescription) {
		fields = append(fields, synctask.FieldDescription)
	}
	if m.FieldCleared(synctask.FieldSyncState) {
		fields = append(fields, synctask.FieldSyncState)
	}
	if m.FieldCleared(synctask.FieldRemark) {
		fields = append(fields, synctask.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SyncTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SyncTaskMutation) ClearField(name string) error {
	switch name {
	case synctask.FieldChainType:
		m.ClearChainType()
		return nil
	case synctask.FieldDescription:
		m.ClearDescription()
		return nil
	case synctask.FieldSyncState:
		m.ClearSyncState()
		return nil
	case synctask.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown SyncTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SyncTaskMutation) ResetField(name string) error {
	switch name {
	case synctask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case synctask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case synctask.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case synctask.FieldChainType:
		m.ResetChainType()
		return nil
	case synctask.FieldChainID:
		m.ResetChainID()
		return nil
	case synctask.FieldStart:
		m.ResetStart()
		return nil
	case synctask.FieldEnd:
		m.ResetEnd()
		return nil
	case synctask.FieldCurrent:
		m.ResetCurrent()
		return nil
	case synctask.FieldTopic:
		m.ResetTopic()
		return nil
	case synctask.FieldDescription:
		m.ResetDescription()
		return nil
	case synctask.FieldSyncState:
		m.ResetSyncState()
		return nil
	case synctask.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown SyncTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SyncTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SyncTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SyncTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SyncTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SyncTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SyncTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SyncTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SyncTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SyncTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SyncTask edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *uint32
	addcreated_at     *int32
	updated_at        *uint32
	addupdated_at     *int32
	deleted_at        *uint32
	adddeleted_at     *int32
	chain_type        *string
	chain_id          *string
	contract          *string
	token_type        *string
	token_id          *string
	owner             *string
	uri               *string
	uri_type          *string
	image_url         *string
	video_url         *string
	description       *string
	name              *string
	vector_id         *int64
	addvector_id      *int64
	vector_state      *string
	remark            *string
	ipfs_image_url    *string
	image_snapshot_id *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Token, error)
	predicates        []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id uuid.UUID) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TokenMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TokenMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TokenMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TokenMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TokenMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TokenMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TokenMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TokenMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetChainType sets the "chain_type" field.
func (m *TokenMutation) SetChainType(s string) {
	m.chain_type = &s
}

// ChainType returns the value of the "chain_type" field in the mutation.
func (m *TokenMutation) ChainType() (r string, exists bool) {
	v := m.chain_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChainType returns the old "chain_type" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldChainType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainType: %w", err)
	}
	return oldValue.ChainType, nil
}

// ResetChainType resets all changes to the "chain_type" field.
func (m *TokenMutation) ResetChainType() {
	m.chain_type = nil
}

// SetChainID sets the "chain_id" field.
func (m *TokenMutation) SetChainID(s string) {
	m.chain_id = &s
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *TokenMutation) ChainID() (r string, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldChainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *TokenMutation) ResetChainID() {
	m.chain_id = nil
}

// SetContract sets the "contract" field.
func (m *TokenMutation) SetContract(s string) {
	m.contract = &s
}

// Contract returns the value of the "contract" field in the mutation.
func (m *TokenMutation) Contract() (r string, exists bool) {
	v := m.contract
	if v == nil {
		return
	}
	return *v, true
}

// OldContract returns the old "contract" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldContract(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContract is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContract requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContract: %w", err)
	}
	return oldValue.Contract, nil
}

// ResetContract resets all changes to the "contract" field.
func (m *TokenMutation) ResetContract() {
	m.contract = nil
}

// SetTokenType sets the "token_type" field.
func (m *TokenMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *TokenMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *TokenMutation) ResetTokenType() {
	m.token_type = nil
}

// SetTokenID sets the "token_id" field.
func (m *TokenMutation) SetTokenID(s string) {
	m.token_id = &s
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *TokenMutation) TokenID() (r string, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *TokenMutation) ResetTokenID() {
	m.token_id = nil
}

// SetOwner sets the "owner" field.
func (m *TokenMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *TokenMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ClearOwner clears the value of the "owner" field.
func (m *TokenMutation) ClearOwner() {
	m.owner = nil
	m.clearedFields[token.FieldOwner] = struct{}{}
}

// OwnerCleared returns if the "owner" field was cleared in this mutation.
func (m *TokenMutation) OwnerCleared() bool {
	_, ok := m.clearedFields[token.FieldOwner]
	return ok
}

// ResetOwner resets all changes to the "owner" field.
func (m *TokenMutation) ResetOwner() {
	m.owner = nil
	delete(m.clearedFields, token.FieldOwner)
}

// SetURI sets the "uri" field.
func (m *TokenMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *TokenMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ClearURI clears the value of the "uri" field.
func (m *TokenMutation) ClearURI() {
	m.uri = nil
	m.clearedFields[token.FieldURI] = struct{}{}
}

// URICleared returns if the "uri" field was cleared in this mutation.
func (m *TokenMutation) URICleared() bool {
	_, ok := m.clearedFields[token.FieldURI]
	return ok
}

// ResetURI resets all changes to the "uri" field.
func (m *TokenMutation) ResetURI() {
	m.uri = nil
	delete(m.clearedFields, token.FieldURI)
}

// SetURIType sets the "uri_type" field.
func (m *TokenMutation) SetURIType(s string) {
	m.uri_type = &s
}

// URIType returns the value of the "uri_type" field in the mutation.
func (m *TokenMutation) URIType() (r string, exists bool) {
	v := m.uri_type
	if v == nil {
		return
	}
	return *v, true
}

// OldURIType returns the old "uri_type" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldURIType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURIType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURIType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURIType: %w", err)
	}
	return oldValue.URIType, nil
}

// ClearURIType clears the value of the "uri_type" field.
func (m *TokenMutation) ClearURIType() {
	m.uri_type = nil
	m.clearedFields[token.FieldURIType] = struct{}{}
}

// URITypeCleared returns if the "uri_type" field was cleared in this mutation.
func (m *TokenMutation) URITypeCleared() bool {
	_, ok := m.clearedFields[token.FieldURIType]
	return ok
}

// ResetURIType resets all changes to the "uri_type" field.
func (m *TokenMutation) ResetURIType() {
	m.uri_type = nil
	delete(m.clearedFields, token.FieldURIType)
}

// SetImageURL sets the "image_url" field.
func (m *TokenMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *TokenMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *TokenMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[token.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *TokenMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[token.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *TokenMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, token.FieldImageURL)
}

// SetVideoURL sets the "video_url" field.
func (m *TokenMutation) SetVideoURL(s string) {
	m.video_url = &s
}

// VideoURL returns the value of the "video_url" field in the mutation.
func (m *TokenMutation) VideoURL() (r string, exists bool) {
	v := m.video_url
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoURL returns the old "video_url" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldVideoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoURL: %w", err)
	}
	return oldValue.VideoURL, nil
}

// ClearVideoURL clears the value of the "video_url" field.
func (m *TokenMutation) ClearVideoURL() {
	m.video_url = nil
	m.clearedFields[token.FieldVideoURL] = struct{}{}
}

// VideoURLCleared returns if the "video_url" field was cleared in this mutation.
func (m *TokenMutation) VideoURLCleared() bool {
	_, ok := m.clearedFields[token.FieldVideoURL]
	return ok
}

// ResetVideoURL resets all changes to the "video_url" field.
func (m *TokenMutation) ResetVideoURL() {
	m.video_url = nil
	delete(m.clearedFields, token.FieldVideoURL)
}

// SetDescription sets the "description" field.
func (m *TokenMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TokenMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TokenMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[token.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TokenMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[token.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TokenMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, token.FieldDescription)
}

// SetName sets the "name" field.
func (m *TokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TokenMutation) ClearName() {
	m.name = nil
	m.clearedFields[token.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TokenMutation) NameCleared() bool {
	_, ok := m.clearedFields[token.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TokenMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, token.FieldName)
}

// SetVectorID sets the "vector_id" field.
func (m *TokenMutation) SetVectorID(i int64) {
	m.vector_id = &i
	m.addvector_id = nil
}

// VectorID returns the value of the "vector_id" field in the mutation.
func (m *TokenMutation) VectorID() (r int64, exists bool) {
	v := m.vector_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVectorID returns the old "vector_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldVectorID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVectorID: %w", err)
	}
	return oldValue.VectorID, nil
}

// AddVectorID adds i to the "vector_id" field.
func (m *TokenMutation) AddVectorID(i int64) {
	if m.addvector_id != nil {
		*m.addvector_id += i
	} else {
		m.addvector_id = &i
	}
}

// AddedVectorID returns the value that was added to the "vector_id" field in this mutation.
func (m *TokenMutation) AddedVectorID() (r int64, exists bool) {
	v := m.addvector_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVectorID clears the value of the "vector_id" field.
func (m *TokenMutation) ClearVectorID() {
	m.vector_id = nil
	m.addvector_id = nil
	m.clearedFields[token.FieldVectorID] = struct{}{}
}

// VectorIDCleared returns if the "vector_id" field was cleared in this mutation.
func (m *TokenMutation) VectorIDCleared() bool {
	_, ok := m.clearedFields[token.FieldVectorID]
	return ok
}

// ResetVectorID resets all changes to the "vector_id" field.
func (m *TokenMutation) ResetVectorID() {
	m.vector_id = nil
	m.addvector_id = nil
	delete(m.clearedFields, token.FieldVectorID)
}

// SetVectorState sets the "vector_state" field.
func (m *TokenMutation) SetVectorState(s string) {
	m.vector_state = &s
}

// VectorState returns the value of the "vector_state" field in the mutation.
func (m *TokenMutation) VectorState() (r string, exists bool) {
	v := m.vector_state
	if v == nil {
		return
	}
	return *v, true
}

// OldVectorState returns the old "vector_state" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldVectorState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVectorState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVectorState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVectorState: %w", err)
	}
	return oldValue.VectorState, nil
}

// ClearVectorState clears the value of the "vector_state" field.
func (m *TokenMutation) ClearVectorState() {
	m.vector_state = nil
	m.clearedFields[token.FieldVectorState] = struct{}{}
}

// VectorStateCleared returns if the "vector_state" field was cleared in this mutation.
func (m *TokenMutation) VectorStateCleared() bool {
	_, ok := m.clearedFields[token.FieldVectorState]
	return ok
}

// ResetVectorState resets all changes to the "vector_state" field.
func (m *TokenMutation) ResetVectorState() {
	m.vector_state = nil
	delete(m.clearedFields, token.FieldVectorState)
}

// SetRemark sets the "remark" field.
func (m *TokenMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TokenMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *TokenMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[token.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *TokenMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[token.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *TokenMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, token.FieldRemark)
}

// SetIpfsImageURL sets the "ipfs_image_url" field.
func (m *TokenMutation) SetIpfsImageURL(s string) {
	m.ipfs_image_url = &s
}

// IpfsImageURL returns the value of the "ipfs_image_url" field in the mutation.
func (m *TokenMutation) IpfsImageURL() (r string, exists bool) {
	v := m.ipfs_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIpfsImageURL returns the old "ipfs_image_url" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldIpfsImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIpfsImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIpfsImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIpfsImageURL: %w", err)
	}
	return oldValue.IpfsImageURL, nil
}

// ClearIpfsImageURL clears the value of the "ipfs_image_url" field.
func (m *TokenMutation) ClearIpfsImageURL() {
	m.ipfs_image_url = nil
	m.clearedFields[token.FieldIpfsImageURL] = struct{}{}
}

// IpfsImageURLCleared returns if the "ipfs_image_url" field was cleared in this mutation.
func (m *TokenMutation) IpfsImageURLCleared() bool {
	_, ok := m.clearedFields[token.FieldIpfsImageURL]
	return ok
}

// ResetIpfsImageURL resets all changes to the "ipfs_image_url" field.
func (m *TokenMutation) ResetIpfsImageURL() {
	m.ipfs_image_url = nil
	delete(m.clearedFields, token.FieldIpfsImageURL)
}

// SetImageSnapshotID sets the "image_snapshot_id" field.
func (m *TokenMutation) SetImageSnapshotID(s string) {
	m.image_snapshot_id = &s
}

// ImageSnapshotID returns the value of the "image_snapshot_id" field in the mutation.
func (m *TokenMutation) ImageSnapshotID() (r string, exists bool) {
	v := m.image_snapshot_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImageSnapshotID returns the old "image_snapshot_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldImageSnapshotID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageSnapshotID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageSnapshotID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageSnapshotID: %w", err)
	}
	return oldValue.ImageSnapshotID, nil
}

// ClearImageSnapshotID clears the value of the "image_snapshot_id" field.
func (m *TokenMutation) ClearImageSnapshotID() {
	m.image_snapshot_id = nil
	m.clearedFields[token.FieldImageSnapshotID] = struct{}{}
}

// ImageSnapshotIDCleared returns if the "image_snapshot_id" field was cleared in this mutation.
func (m *TokenMutation) ImageSnapshotIDCleared() bool {
	_, ok := m.clearedFields[token.FieldImageSnapshotID]
	return ok
}

// ResetImageSnapshotID resets all changes to the "image_snapshot_id" field.
func (m *TokenMutation) ResetImageSnapshotID() {
	m.image_snapshot_id = nil
	delete(m.clearedFields, token.FieldImageSnapshotID)
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, token.FieldDeletedAt)
	}
	if m.chain_type != nil {
		fields = append(fields, token.FieldChainType)
	}
	if m.chain_id != nil {
		fields = append(fields, token.FieldChainID)
	}
	if m.contract != nil {
		fields = append(fields, token.FieldContract)
	}
	if m.token_type != nil {
		fields = append(fields, token.FieldTokenType)
	}
	if m.token_id != nil {
		fields = append(fields, token.FieldTokenID)
	}
	if m.owner != nil {
		fields = append(fields, token.FieldOwner)
	}
	if m.uri != nil {
		fields = append(fields, token.FieldURI)
	}
	if m.uri_type != nil {
		fields = append(fields, token.FieldURIType)
	}
	if m.image_url != nil {
		fields = append(fields, token.FieldImageURL)
	}
	if m.video_url != nil {
		fields = append(fields, token.FieldVideoURL)
	}
	if m.description != nil {
		fields = append(fields, token.FieldDescription)
	}
	if m.name != nil {
		fields = append(fields, token.FieldName)
	}
	if m.vector_id != nil {
		fields = append(fields, token.FieldVectorID)
	}
	if m.vector_state != nil {
		fields = append(fields, token.FieldVectorState)
	}
	if m.remark != nil {
		fields = append(fields, token.FieldRemark)
	}
	if m.ipfs_image_url != nil {
		fields = append(fields, token.FieldIpfsImageURL)
	}
	if m.image_snapshot_id != nil {
		fields = append(fields, token.FieldImageSnapshotID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldDeletedAt:
		return m.DeletedAt()
	case token.FieldChainType:
		return m.ChainType()
	case token.FieldChainID:
		return m.ChainID()
	case token.FieldContract:
		return m.Contract()
	case token.FieldTokenType:
		return m.TokenType()
	case token.FieldTokenID:
		return m.TokenID()
	case token.FieldOwner:
		return m.Owner()
	case token.FieldURI:
		return m.URI()
	case token.FieldURIType:
		return m.URIType()
	case token.FieldImageURL:
		return m.ImageURL()
	case token.FieldVideoURL:
		return m.VideoURL()
	case token.FieldDescription:
		return m.Description()
	case token.FieldName:
		return m.Name()
	case token.FieldVectorID:
		return m.VectorID()
	case token.FieldVectorState:
		return m.VectorState()
	case token.FieldRemark:
		return m.Remark()
	case token.FieldIpfsImageURL:
		return m.IpfsImageURL()
	case token.FieldImageSnapshotID:
		return m.ImageSnapshotID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case token.FieldChainType:
		return m.OldChainType(ctx)
	case token.FieldChainID:
		return m.OldChainID(ctx)
	case token.FieldContract:
		return m.OldContract(ctx)
	case token.FieldTokenType:
		return m.OldTokenType(ctx)
	case token.FieldTokenID:
		return m.OldTokenID(ctx)
	case token.FieldOwner:
		return m.OldOwner(ctx)
	case token.FieldURI:
		return m.OldURI(ctx)
	case token.FieldURIType:
		return m.OldURIType(ctx)
	case token.FieldImageURL:
		return m.OldImageURL(ctx)
	case token.FieldVideoURL:
		return m.OldVideoURL(ctx)
	case token.FieldDescription:
		return m.OldDescription(ctx)
	case token.FieldName:
		return m.OldName(ctx)
	case token.FieldVectorID:
		return m.OldVectorID(ctx)
	case token.FieldVectorState:
		return m.OldVectorState(ctx)
	case token.FieldRemark:
		return m.OldRemark(ctx)
	case token.FieldIpfsImageURL:
		return m.OldIpfsImageURL(ctx)
	case token.FieldImageSnapshotID:
		return m.OldImageSnapshotID(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case token.FieldChainType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainType(v)
		return nil
	case token.FieldChainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case token.FieldContract:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContract(v)
		return nil
	case token.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case token.FieldTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case token.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case token.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case token.FieldURIType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURIType(v)
		return nil
	case token.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case token.FieldVideoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoURL(v)
		return nil
	case token.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case token.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case token.FieldVectorID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVectorID(v)
		return nil
	case token.FieldVectorState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVectorState(v)
		return nil
	case token.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case token.FieldIpfsImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIpfsImageURL(v)
		return nil
	case token.FieldImageSnapshotID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageSnapshotID(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, token.FieldDeletedAt)
	}
	if m.addvector_id != nil {
		fields = append(fields, token.FieldVectorID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.AddedCreatedAt()
	case token.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case token.FieldDeletedAt:
		return m.AddedDeletedAt()
	case token.FieldVectorID:
		return m.AddedVectorID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case token.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case token.FieldVectorID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVectorID(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldOwner) {
		fields = append(fields, token.FieldOwner)
	}
	if m.FieldCleared(token.FieldURI) {
		fields = append(fields, token.FieldURI)
	}
	if m.FieldCleared(token.FieldURIType) {
		fields = append(fields, token.FieldURIType)
	}
	if m.FieldCleared(token.FieldImageURL) {
		fields = append(fields, token.FieldImageURL)
	}
	if m.FieldCleared(token.FieldVideoURL) {
		fields = append(fields, token.FieldVideoURL)
	}
	if m.FieldCleared(token.FieldDescription) {
		fields = append(fields, token.FieldDescription)
	}
	if m.FieldCleared(token.FieldName) {
		fields = append(fields, token.FieldName)
	}
	if m.FieldCleared(token.FieldVectorID) {
		fields = append(fields, token.FieldVectorID)
	}
	if m.FieldCleared(token.FieldVectorState) {
		fields = append(fields, token.FieldVectorState)
	}
	if m.FieldCleared(token.FieldRemark) {
		fields = append(fields, token.FieldRemark)
	}
	if m.FieldCleared(token.FieldIpfsImageURL) {
		fields = append(fields, token.FieldIpfsImageURL)
	}
	if m.FieldCleared(token.FieldImageSnapshotID) {
		fields = append(fields, token.FieldImageSnapshotID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldOwner:
		m.ClearOwner()
		return nil
	case token.FieldURI:
		m.ClearURI()
		return nil
	case token.FieldURIType:
		m.ClearURIType()
		return nil
	case token.FieldImageURL:
		m.ClearImageURL()
		return nil
	case token.FieldVideoURL:
		m.ClearVideoURL()
		return nil
	case token.FieldDescription:
		m.ClearDescription()
		return nil
	case token.FieldName:
		m.ClearName()
		return nil
	case token.FieldVectorID:
		m.ClearVectorID()
		return nil
	case token.FieldVectorState:
		m.ClearVectorState()
		return nil
	case token.FieldRemark:
		m.ClearRemark()
		return nil
	case token.FieldIpfsImageURL:
		m.ClearIpfsImageURL()
		return nil
	case token.FieldImageSnapshotID:
		m.ClearImageSnapshotID()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case token.FieldChainType:
		m.ResetChainType()
		return nil
	case token.FieldChainID:
		m.ResetChainID()
		return nil
	case token.FieldContract:
		m.ResetContract()
		return nil
	case token.FieldTokenType:
		m.ResetTokenType()
		return nil
	case token.FieldTokenID:
		m.ResetTokenID()
		return nil
	case token.FieldOwner:
		m.ResetOwner()
		return nil
	case token.FieldURI:
		m.ResetURI()
		return nil
	case token.FieldURIType:
		m.ResetURIType()
		return nil
	case token.FieldImageURL:
		m.ResetImageURL()
		return nil
	case token.FieldVideoURL:
		m.ResetVideoURL()
		return nil
	case token.FieldDescription:
		m.ResetDescription()
		return nil
	case token.FieldName:
		m.ResetName()
		return nil
	case token.FieldVectorID:
		m.ResetVectorID()
		return nil
	case token.FieldVectorState:
		m.ResetVectorState()
		return nil
	case token.FieldRemark:
		m.ResetRemark()
		return nil
	case token.FieldIpfsImageURL:
		m.ResetIpfsImageURL()
		return nil
	case token.FieldImageSnapshotID:
		m.ResetImageSnapshotID()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Token edge %s", name)
}

// TransferMutation represents an operation that mutates the Transfer nodes in the graph.
type TransferMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	chain_type      *string
	chain_id        *string
	contract        *string
	token_type      *string
	token_id        *string
	from            *string
	to              *string
	amount          *uint64
	addamount       *int64
	block_number    *uint64
	addblock_number *int64
	tx_hash         *string
	block_hash      *string
	tx_time         *uint32
	addtx_time      *int32
	remark          *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Transfer, error)
	predicates      []predicate.Transfer
}

var _ ent.Mutation = (*TransferMutation)(nil)

// transferOption allows management of the mutation configuration using functional options.
type transferOption func(*TransferMutation)

// newTransferMutation creates new mutation for the Transfer entity.
func newTransferMutation(c config, op Op, opts ...transferOption) *TransferMutation {
	m := &TransferMutation{
		config:        c,
		op:            op,
		typ:           TypeTransfer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferID sets the ID field of the mutation.
func withTransferID(id uuid.UUID) transferOption {
	return func(m *TransferMutation) {
		var (
			err   error
			once  sync.Once
			value *Transfer
		)
		m.oldValue = func(ctx context.Context) (*Transfer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transfer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransfer sets the old Transfer of the mutation.
func withTransfer(node *Transfer) transferOption {
	return func(m *TransferMutation) {
		m.oldValue = func(context.Context) (*Transfer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transfer entities.
func (m *TransferMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transfer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransferMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransferMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TransferMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TransferMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransferMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransferMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransferMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TransferMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TransferMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransferMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TransferMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TransferMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TransferMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TransferMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TransferMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetChainType sets the "chain_type" field.
func (m *TransferMutation) SetChainType(s string) {
	m.chain_type = &s
}

// ChainType returns the value of the "chain_type" field in the mutation.
func (m *TransferMutation) ChainType() (r string, exists bool) {
	v := m.chain_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChainType returns the old "chain_type" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldChainType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainType: %w", err)
	}
	return oldValue.ChainType, nil
}

// ResetChainType resets all changes to the "chain_type" field.
func (m *TransferMutation) ResetChainType() {
	m.chain_type = nil
}

// SetChainID sets the "chain_id" field.
func (m *TransferMutation) SetChainID(s string) {
	m.chain_id = &s
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *TransferMutation) ChainID() (r string, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldChainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *TransferMutation) ResetChainID() {
	m.chain_id = nil
}

// SetContract sets the "contract" field.
func (m *TransferMutation) SetContract(s string) {
	m.contract = &s
}

// Contract returns the value of the "contract" field in the mutation.
func (m *TransferMutation) Contract() (r string, exists bool) {
	v := m.contract
	if v == nil {
		return
	}
	return *v, true
}

// OldContract returns the old "contract" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldContract(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContract is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContract requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContract: %w", err)
	}
	return oldValue.Contract, nil
}

// ResetContract resets all changes to the "contract" field.
func (m *TransferMutation) ResetContract() {
	m.contract = nil
}

// SetTokenType sets the "token_type" field.
func (m *TransferMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *TransferMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *TransferMutation) ResetTokenType() {
	m.token_type = nil
}

// SetTokenID sets the "token_id" field.
func (m *TransferMutation) SetTokenID(s string) {
	m.token_id = &s
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *TransferMutation) TokenID() (r string, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *TransferMutation) ResetTokenID() {
	m.token_id = nil
}

// SetFrom sets the "from" field.
func (m *TransferMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the value of the "from" field in the mutation.
func (m *TransferMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom resets all changes to the "from" field.
func (m *TransferMutation) ResetFrom() {
	m.from = nil
}

// SetTo sets the "to" field.
func (m *TransferMutation) SetTo(s string) {
	m.to = &s
}

// To returns the value of the "to" field in the mutation.
func (m *TransferMutation) To() (r string, exists bool) {
	v := m.to
	if v == nil {
		return
	}
	return *v, true
}

// OldTo returns the old "to" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTo: %w", err)
	}
	return oldValue.To, nil
}

// ResetTo resets all changes to the "to" field.
func (m *TransferMutation) ResetTo() {
	m.to = nil
}

// SetAmount sets the "amount" field.
func (m *TransferMutation) SetAmount(u uint64) {
	m.amount = &u
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransferMutation) Amount() (r uint64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldAmount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds u to the "amount" field.
func (m *TransferMutation) AddAmount(u int64) {
	if m.addamount != nil {
		*m.addamount += u
	} else {
		m.addamount = &u
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransferMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransferMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetBlockNumber sets the "block_number" field.
func (m *TransferMutation) SetBlockNumber(u uint64) {
	m.block_number = &u
	m.addblock_number = nil
}

// BlockNumber returns the value of the "block_number" field in the mutation.
func (m *TransferMutation) BlockNumber() (r uint64, exists bool) {
	v := m.block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "block_number" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldBlockNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds u to the "block_number" field.
func (m *TransferMutation) AddBlockNumber(u int64) {
	if m.addblock_number != nil {
		*m.addblock_number += u
	} else {
		m.addblock_number = &u
	}
}

// AddedBlockNumber returns the value that was added to the "block_number" field in this mutation.
func (m *TransferMutation) AddedBlockNumber() (r int64, exists bool) {
	v := m.addblock_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "block_number" field.
func (m *TransferMutation) ResetBlockNumber() {
	m.block_number = nil
	m.addblock_number = nil
}

// SetTxHash sets the "tx_hash" field.
func (m *TransferMutation) SetTxHash(s string) {
	m.tx_hash = &s
}

// TxHash returns the value of the "tx_hash" field in the mutation.
func (m *TransferMutation) TxHash() (r string, exists bool) {
	v := m.tx_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTxHash returns the old "tx_hash" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldTxHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxHash: %w", err)
	}
	return oldValue.TxHash, nil
}

// ResetTxHash resets all changes to the "tx_hash" field.
func (m *TransferMutation) ResetTxHash() {
	m.tx_hash = nil
}

// SetBlockHash sets the "block_hash" field.
func (m *TransferMutation) SetBlockHash(s string) {
	m.block_hash = &s
}

// BlockHash returns the value of the "block_hash" field in the mutation.
func (m *TransferMutation) BlockHash() (r string, exists bool) {
	v := m.block_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockHash returns the old "block_hash" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldBlockHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockHash: %w", err)
	}
	return oldValue.BlockHash, nil
}

// ResetBlockHash resets all changes to the "block_hash" field.
func (m *TransferMutation) ResetBlockHash() {
	m.block_hash = nil
}

// SetTxTime sets the "tx_time" field.
func (m *TransferMutation) SetTxTime(u uint32) {
	m.tx_time = &u
	m.addtx_time = nil
}

// TxTime returns the value of the "tx_time" field in the mutation.
func (m *TransferMutation) TxTime() (r uint32, exists bool) {
	v := m.tx_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTxTime returns the old "tx_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldTxTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxTime: %w", err)
	}
	return oldValue.TxTime, nil
}

// AddTxTime adds u to the "tx_time" field.
func (m *TransferMutation) AddTxTime(u int32) {
	if m.addtx_time != nil {
		*m.addtx_time += u
	} else {
		m.addtx_time = &u
	}
}

// AddedTxTime returns the value that was added to the "tx_time" field in this mutation.
func (m *TransferMutation) AddedTxTime() (r int32, exists bool) {
	v := m.addtx_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearTxTime clears the value of the "tx_time" field.
func (m *TransferMutation) ClearTxTime() {
	m.tx_time = nil
	m.addtx_time = nil
	m.clearedFields[transfer.FieldTxTime] = struct{}{}
}

// TxTimeCleared returns if the "tx_time" field was cleared in this mutation.
func (m *TransferMutation) TxTimeCleared() bool {
	_, ok := m.clearedFields[transfer.FieldTxTime]
	return ok
}

// ResetTxTime resets all changes to the "tx_time" field.
func (m *TransferMutation) ResetTxTime() {
	m.tx_time = nil
	m.addtx_time = nil
	delete(m.clearedFields, transfer.FieldTxTime)
}

// SetRemark sets the "remark" field.
func (m *TransferMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TransferMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *TransferMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[transfer.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *TransferMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[transfer.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *TransferMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, transfer.FieldRemark)
}

// Where appends a list predicates to the TransferMutation builder.
func (m *TransferMutation) Where(ps ...predicate.Transfer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransferMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transfer).
func (m *TransferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, transfer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transfer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, transfer.FieldDeletedAt)
	}
	if m.chain_type != nil {
		fields = append(fields, transfer.FieldChainType)
	}
	if m.chain_id != nil {
		fields = append(fields, transfer.FieldChainID)
	}
	if m.contract != nil {
		fields = append(fields, transfer.FieldContract)
	}
	if m.token_type != nil {
		fields = append(fields, transfer.FieldTokenType)
	}
	if m.token_id != nil {
		fields = append(fields, transfer.FieldTokenID)
	}
	if m.from != nil {
		fields = append(fields, transfer.FieldFrom)
	}
	if m.to != nil {
		fields = append(fields, transfer.FieldTo)
	}
	if m.amount != nil {
		fields = append(fields, transfer.FieldAmount)
	}
	if m.block_number != nil {
		fields = append(fields, transfer.FieldBlockNumber)
	}
	if m.tx_hash != nil {
		fields = append(fields, transfer.FieldTxHash)
	}
	if m.block_hash != nil {
		fields = append(fields, transfer.FieldBlockHash)
	}
	if m.tx_time != nil {
		fields = append(fields, transfer.FieldTxTime)
	}
	if m.remark != nil {
		fields = append(fields, transfer.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldCreatedAt:
		return m.CreatedAt()
	case transfer.FieldUpdatedAt:
		return m.UpdatedAt()
	case transfer.FieldDeletedAt:
		return m.DeletedAt()
	case transfer.FieldChainType:
		return m.ChainType()
	case transfer.FieldChainID:
		return m.ChainID()
	case transfer.FieldContract:
		return m.Contract()
	case transfer.FieldTokenType:
		return m.TokenType()
	case transfer.FieldTokenID:
		return m.TokenID()
	case transfer.FieldFrom:
		return m.From()
	case transfer.FieldTo:
		return m.To()
	case transfer.FieldAmount:
		return m.Amount()
	case transfer.FieldBlockNumber:
		return m.BlockNumber()
	case transfer.FieldTxHash:
		return m.TxHash()
	case transfer.FieldBlockHash:
		return m.BlockHash()
	case transfer.FieldTxTime:
		return m.TxTime()
	case transfer.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transfer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transfer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transfer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case transfer.FieldChainType:
		return m.OldChainType(ctx)
	case transfer.FieldChainID:
		return m.OldChainID(ctx)
	case transfer.FieldContract:
		return m.OldContract(ctx)
	case transfer.FieldTokenType:
		return m.OldTokenType(ctx)
	case transfer.FieldTokenID:
		return m.OldTokenID(ctx)
	case transfer.FieldFrom:
		return m.OldFrom(ctx)
	case transfer.FieldTo:
		return m.OldTo(ctx)
	case transfer.FieldAmount:
		return m.OldAmount(ctx)
	case transfer.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case transfer.FieldTxHash:
		return m.OldTxHash(ctx)
	case transfer.FieldBlockHash:
		return m.OldBlockHash(ctx)
	case transfer.FieldTxTime:
		return m.OldTxTime(ctx)
	case transfer.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Transfer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transfer.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transfer.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case transfer.FieldChainType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainType(v)
		return nil
	case transfer.FieldChainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case transfer.FieldContract:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContract(v)
		return nil
	case transfer.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case transfer.FieldTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case transfer.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case transfer.FieldTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTo(v)
		return nil
	case transfer.FieldAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transfer.FieldBlockNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case transfer.FieldTxHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxHash(v)
		return nil
	case transfer.FieldBlockHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockHash(v)
		return nil
	case transfer.FieldTxTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxTime(v)
		return nil
	case transfer.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, transfer.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, transfer.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, transfer.FieldDeletedAt)
	}
	if m.addamount != nil {
		fields = append(fields, transfer.FieldAmount)
	}
	if m.addblock_number != nil {
		fields = append(fields, transfer.FieldBlockNumber)
	}
	if m.addtx_time != nil {
		fields = append(fields, transfer.FieldTxTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldCreatedAt:
		return m.AddedCreatedAt()
	case transfer.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case transfer.FieldDeletedAt:
		return m.AddedDeletedAt()
	case transfer.FieldAmount:
		return m.AddedAmount()
	case transfer.FieldBlockNumber:
		return m.AddedBlockNumber()
	case transfer.FieldTxTime:
		return m.AddedTxTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case transfer.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case transfer.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case transfer.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case transfer.FieldBlockNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	case transfer.FieldTxTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTxTime(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transfer.FieldTxTime) {
		fields = append(fields, transfer.FieldTxTime)
	}
	if m.FieldCleared(transfer.FieldRemark) {
		fields = append(fields, transfer.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferMutation) ClearField(name string) error {
	switch name {
	case transfer.FieldTxTime:
		m.ClearTxTime()
		return nil
	case transfer.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Transfer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferMutation) ResetField(name string) error {
	switch name {
	case transfer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transfer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transfer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case transfer.FieldChainType:
		m.ResetChainType()
		return nil
	case transfer.FieldChainID:
		m.ResetChainID()
		return nil
	case transfer.FieldContract:
		m.ResetContract()
		return nil
	case transfer.FieldTokenType:
		m.ResetTokenType()
		return nil
	case transfer.FieldTokenID:
		m.ResetTokenID()
		return nil
	case transfer.FieldFrom:
		m.ResetFrom()
		return nil
	case transfer.FieldTo:
		m.ResetTo()
		return nil
	case transfer.FieldAmount:
		m.ResetAmount()
		return nil
	case transfer.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case transfer.FieldTxHash:
		m.ResetTxHash()
		return nil
	case transfer.FieldBlockHash:
		m.ResetBlockHash()
		return nil
	case transfer.FieldTxTime:
		m.ResetTxTime()
		return nil
	case transfer.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Transfer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Transfer edge %s", name)
}
