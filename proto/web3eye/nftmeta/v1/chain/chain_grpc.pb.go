// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.18.1
// source: web3eye/nftmeta/v1/chain/chain.proto

package chain

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Manager_CreateChain_FullMethodName     = "/nftmeta.v1.chain1.Manager/CreateChain"
	Manager_CreateChains_FullMethodName    = "/nftmeta.v1.chain1.Manager/CreateChains"
	Manager_UpdateChain_FullMethodName     = "/nftmeta.v1.chain1.Manager/UpdateChain"
	Manager_GetChain_FullMethodName        = "/nftmeta.v1.chain1.Manager/GetChain"
	Manager_GetChainOnly_FullMethodName    = "/nftmeta.v1.chain1.Manager/GetChainOnly"
	Manager_GetChains_FullMethodName       = "/nftmeta.v1.chain1.Manager/GetChains"
	Manager_ExistChain_FullMethodName      = "/nftmeta.v1.chain1.Manager/ExistChain"
	Manager_ExistChainConds_FullMethodName = "/nftmeta.v1.chain1.Manager/ExistChainConds"
	Manager_DeleteChain_FullMethodName     = "/nftmeta.v1.chain1.Manager/DeleteChain"
)

// ManagerClient is the client API for Manager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagerClient interface {
	CreateChain(ctx context.Context, in *CreateChainRequest, opts ...grpc.CallOption) (*CreateChainResponse, error)
	CreateChains(ctx context.Context, in *CreateChainsRequest, opts ...grpc.CallOption) (*CreateChainsResponse, error)
	UpdateChain(ctx context.Context, in *UpdateChainRequest, opts ...grpc.CallOption) (*UpdateChainResponse, error)
	GetChain(ctx context.Context, in *GetChainRequest, opts ...grpc.CallOption) (*GetChainResponse, error)
	GetChainOnly(ctx context.Context, in *GetChainOnlyRequest, opts ...grpc.CallOption) (*GetChainOnlyResponse, error)
	GetChains(ctx context.Context, in *GetChainsRequest, opts ...grpc.CallOption) (*GetChainsResponse, error)
	ExistChain(ctx context.Context, in *ExistChainRequest, opts ...grpc.CallOption) (*ExistChainResponse, error)
	ExistChainConds(ctx context.Context, in *ExistChainCondsRequest, opts ...grpc.CallOption) (*ExistChainCondsResponse, error)
	DeleteChain(ctx context.Context, in *DeleteChainRequest, opts ...grpc.CallOption) (*DeleteChainResponse, error)
}

type managerClient struct {
	cc grpc.ClientConnInterface
}

func NewManagerClient(cc grpc.ClientConnInterface) ManagerClient {
	return &managerClient{cc}
}

func (c *managerClient) CreateChain(ctx context.Context, in *CreateChainRequest, opts ...grpc.CallOption) (*CreateChainResponse, error) {
	out := new(CreateChainResponse)
	err := c.cc.Invoke(ctx, Manager_CreateChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) CreateChains(ctx context.Context, in *CreateChainsRequest, opts ...grpc.CallOption) (*CreateChainsResponse, error) {
	out := new(CreateChainsResponse)
	err := c.cc.Invoke(ctx, Manager_CreateChains_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) UpdateChain(ctx context.Context, in *UpdateChainRequest, opts ...grpc.CallOption) (*UpdateChainResponse, error) {
	out := new(UpdateChainResponse)
	err := c.cc.Invoke(ctx, Manager_UpdateChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) GetChain(ctx context.Context, in *GetChainRequest, opts ...grpc.CallOption) (*GetChainResponse, error) {
	out := new(GetChainResponse)
	err := c.cc.Invoke(ctx, Manager_GetChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) GetChainOnly(ctx context.Context, in *GetChainOnlyRequest, opts ...grpc.CallOption) (*GetChainOnlyResponse, error) {
	out := new(GetChainOnlyResponse)
	err := c.cc.Invoke(ctx, Manager_GetChainOnly_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) GetChains(ctx context.Context, in *GetChainsRequest, opts ...grpc.CallOption) (*GetChainsResponse, error) {
	out := new(GetChainsResponse)
	err := c.cc.Invoke(ctx, Manager_GetChains_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) ExistChain(ctx context.Context, in *ExistChainRequest, opts ...grpc.CallOption) (*ExistChainResponse, error) {
	out := new(ExistChainResponse)
	err := c.cc.Invoke(ctx, Manager_ExistChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) ExistChainConds(ctx context.Context, in *ExistChainCondsRequest, opts ...grpc.CallOption) (*ExistChainCondsResponse, error) {
	out := new(ExistChainCondsResponse)
	err := c.cc.Invoke(ctx, Manager_ExistChainConds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) DeleteChain(ctx context.Context, in *DeleteChainRequest, opts ...grpc.CallOption) (*DeleteChainResponse, error) {
	out := new(DeleteChainResponse)
	err := c.cc.Invoke(ctx, Manager_DeleteChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagerServer is the server API for Manager service.
// All implementations must embed UnimplementedManagerServer
// for forward compatibility
type ManagerServer interface {
	CreateChain(context.Context, *CreateChainRequest) (*CreateChainResponse, error)
	CreateChains(context.Context, *CreateChainsRequest) (*CreateChainsResponse, error)
	UpdateChain(context.Context, *UpdateChainRequest) (*UpdateChainResponse, error)
	GetChain(context.Context, *GetChainRequest) (*GetChainResponse, error)
	GetChainOnly(context.Context, *GetChainOnlyRequest) (*GetChainOnlyResponse, error)
	GetChains(context.Context, *GetChainsRequest) (*GetChainsResponse, error)
	ExistChain(context.Context, *ExistChainRequest) (*ExistChainResponse, error)
	ExistChainConds(context.Context, *ExistChainCondsRequest) (*ExistChainCondsResponse, error)
	DeleteChain(context.Context, *DeleteChainRequest) (*DeleteChainResponse, error)
	mustEmbedUnimplementedManagerServer()
}

// UnimplementedManagerServer must be embedded to have forward compatible implementations.
type UnimplementedManagerServer struct {
}

func (UnimplementedManagerServer) CreateChain(context.Context, *CreateChainRequest) (*CreateChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChain not implemented")
}
func (UnimplementedManagerServer) CreateChains(context.Context, *CreateChainsRequest) (*CreateChainsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChains not implemented")
}
func (UnimplementedManagerServer) UpdateChain(context.Context, *UpdateChainRequest) (*UpdateChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChain not implemented")
}
func (UnimplementedManagerServer) GetChain(context.Context, *GetChainRequest) (*GetChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChain not implemented")
}
func (UnimplementedManagerServer) GetChainOnly(context.Context, *GetChainOnlyRequest) (*GetChainOnlyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChainOnly not implemented")
}
func (UnimplementedManagerServer) GetChains(context.Context, *GetChainsRequest) (*GetChainsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChains not implemented")
}
func (UnimplementedManagerServer) ExistChain(context.Context, *ExistChainRequest) (*ExistChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExistChain not implemented")
}
func (UnimplementedManagerServer) ExistChainConds(context.Context, *ExistChainCondsRequest) (*ExistChainCondsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExistChainConds not implemented")
}
func (UnimplementedManagerServer) DeleteChain(context.Context, *DeleteChainRequest) (*DeleteChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteChain not implemented")
}
func (UnimplementedManagerServer) mustEmbedUnimplementedManagerServer() {}

// UnsafeManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagerServer will
// result in compilation errors.
type UnsafeManagerServer interface {
	mustEmbedUnimplementedManagerServer()
}

func RegisterManagerServer(s grpc.ServiceRegistrar, srv ManagerServer) {
	s.RegisterService(&Manager_ServiceDesc, srv)
}

func _Manager_CreateChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).CreateChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Manager_CreateChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).CreateChain(ctx, req.(*CreateChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_CreateChains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateChainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).CreateChains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Manager_CreateChains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).CreateChains(ctx, req.(*CreateChainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_UpdateChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).UpdateChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Manager_UpdateChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).UpdateChain(ctx, req.(*UpdateChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_GetChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).GetChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Manager_GetChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).GetChain(ctx, req.(*GetChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_GetChainOnly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChainOnlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).GetChainOnly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Manager_GetChainOnly_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).GetChainOnly(ctx, req.(*GetChainOnlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_GetChains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).GetChains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Manager_GetChains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).GetChains(ctx, req.(*GetChainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_ExistChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).ExistChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Manager_ExistChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).ExistChain(ctx, req.(*ExistChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_ExistChainConds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistChainCondsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).ExistChainConds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Manager_ExistChainConds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).ExistChainConds(ctx, req.(*ExistChainCondsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_DeleteChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).DeleteChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Manager_DeleteChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).DeleteChain(ctx, req.(*DeleteChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Manager_ServiceDesc is the grpc.ServiceDesc for Manager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Manager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nftmeta.v1.chain1.Manager",
	HandlerType: (*ManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateChain",
			Handler:    _Manager_CreateChain_Handler,
		},
		{
			MethodName: "CreateChains",
			Handler:    _Manager_CreateChains_Handler,
		},
		{
			MethodName: "UpdateChain",
			Handler:    _Manager_UpdateChain_Handler,
		},
		{
			MethodName: "GetChain",
			Handler:    _Manager_GetChain_Handler,
		},
		{
			MethodName: "GetChainOnly",
			Handler:    _Manager_GetChainOnly_Handler,
		},
		{
			MethodName: "GetChains",
			Handler:    _Manager_GetChains_Handler,
		},
		{
			MethodName: "ExistChain",
			Handler:    _Manager_ExistChain_Handler,
		},
		{
			MethodName: "ExistChainConds",
			Handler:    _Manager_ExistChainConds_Handler,
		},
		{
			MethodName: "DeleteChain",
			Handler:    _Manager_DeleteChain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "web3eye/nftmeta/v1/chain/chain.proto",
}
